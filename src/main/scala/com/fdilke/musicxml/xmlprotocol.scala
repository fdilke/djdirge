// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.fdilke.musicxml

import scala.language.postfixOps

/**
usage:
val obj = scalaxb.fromXML[com.fdilke.musicxml.Foo](node)
val document = scalaxb.toXML[com.fdilke.musicxml.Foo](obj, "foo", com.fdilke.musicxml.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "http://www.w3.org/1999/xlink",
    Some("xlink") -> "http://www.w3.org/1999/xlink",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val MusicxmlTypeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Type] = new DefaultMusicxmlTypeFormat {}
  implicit lazy val MusicxmlShowFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Show] = new DefaultMusicxmlShowFormat {}
  implicit lazy val MusicxmlActuateFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Actuate] = new DefaultMusicxmlActuateFormat {}
  implicit lazy val MusicxmlAboveu45belowFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Aboveu45below] = new DefaultMusicxmlAboveu45belowFormat {}
  implicit lazy val MusicxmlCssu45fontu45sizeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Cssu45fontu45size] = new DefaultMusicxmlCssu45fontu45sizeFormat {}
  implicit lazy val MusicxmlEnclosureu45shapeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Enclosureu45shape] = new DefaultMusicxmlEnclosureu45shapeFormat {}
  implicit lazy val MusicxmlFermatau45shapeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fermatau45shape] = new DefaultMusicxmlFermatau45shapeFormat {}
  implicit lazy val MusicxmlFontu45styleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fontu45style] = new DefaultMusicxmlFontu45styleFormat {}
  implicit lazy val MusicxmlFontu45weightFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fontu45weight] = new DefaultMusicxmlFontu45weightFormat {}
  implicit lazy val MusicxmlLeftu45centeru45rightFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45centeru45right] = new DefaultMusicxmlLeftu45centeru45rightFormat {}
  implicit lazy val MusicxmlLeftu45rightFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45right] = new DefaultMusicxmlLeftu45rightFormat {}
  implicit lazy val MusicxmlLineu45lengthFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45length] = new DefaultMusicxmlLineu45lengthFormat {}
  implicit lazy val MusicxmlLineu45shapeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45shape] = new DefaultMusicxmlLineu45shapeFormat {}
  implicit lazy val MusicxmlLineu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45type] = new DefaultMusicxmlLineu45typeFormat {}
  implicit lazy val MusicxmlMuteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Mute] = new DefaultMusicxmlMuteFormat {}
  implicit lazy val MusicxmlOveru45underFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Overu45under] = new DefaultMusicxmlOveru45underFormat {}
  implicit lazy val MusicxmlSemiu45pitchedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Semiu45pitched] = new DefaultMusicxmlSemiu45pitchedFormat {}
  implicit lazy val MusicxmlStartu45noteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45note] = new DefaultMusicxmlStartu45noteFormat {}
  implicit lazy val MusicxmlStartu45stopFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stop] = new DefaultMusicxmlStartu45stopFormat {}
  implicit lazy val MusicxmlStartu45stopu45continueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45continue] = new DefaultMusicxmlStartu45stopu45continueFormat {}
  implicit lazy val MusicxmlStartu45stopu45singleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45single] = new DefaultMusicxmlStartu45stopu45singleFormat {}
  implicit lazy val MusicxmlSymbolu45sizeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Symbolu45size] = new DefaultMusicxmlSymbolu45sizeFormat {}
  implicit lazy val MusicxmlTextu45directionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Textu45direction] = new DefaultMusicxmlTextu45directionFormat {}
  implicit lazy val MusicxmlTiedu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tiedu45type] = new DefaultMusicxmlTiedu45typeFormat {}
  implicit lazy val MusicxmlTopu45bottomFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Topu45bottom] = new DefaultMusicxmlTopu45bottomFormat {}
  implicit lazy val MusicxmlTremolou45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tremolou45type] = new DefaultMusicxmlTremolou45typeFormat {}
  implicit lazy val MusicxmlTrillu45stepFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Trillu45step] = new DefaultMusicxmlTrillu45stepFormat {}
  implicit lazy val MusicxmlTwou45noteu45turnFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Twou45noteu45turn] = new DefaultMusicxmlTwou45noteu45turnFormat {}
  implicit lazy val MusicxmlUpu45downTypeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Upu45downType] = new DefaultMusicxmlUpu45downTypeFormat {}
  implicit lazy val MusicxmlUprightu45invertedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Uprightu45inverted] = new DefaultMusicxmlUprightu45invertedFormat {}
  implicit lazy val MusicxmlValignFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Valign] = new DefaultMusicxmlValignFormat {}
  implicit lazy val MusicxmlValignu45imageFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Valignu45image] = new DefaultMusicxmlValignu45imageFormat {}
  implicit lazy val MusicxmlYesu45noFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Yesu45no] = new DefaultMusicxmlYesu45noFormat {}
  implicit lazy val MusicxmlCancelu45locationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Cancelu45location] = new DefaultMusicxmlCancelu45locationFormat {}
  implicit lazy val MusicxmlClefu45signFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Clefu45sign] = new DefaultMusicxmlClefu45signFormat {}
  implicit lazy val MusicxmlShowu45fretsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Showu45frets] = new DefaultMusicxmlShowu45fretsFormat {}
  implicit lazy val MusicxmlStaffu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45type] = new DefaultMusicxmlStaffu45typeFormat {}
  implicit lazy val MusicxmlTimeu45relationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45relation] = new DefaultMusicxmlTimeu45relationFormat {}
  implicit lazy val MusicxmlTimeu45separatorFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45separator] = new DefaultMusicxmlTimeu45separatorFormat {}
  implicit lazy val MusicxmlTimeu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45symbol] = new DefaultMusicxmlTimeu45symbolFormat {}
  implicit lazy val MusicxmlBackwardu45forwardFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Backwardu45forward] = new DefaultMusicxmlBackwardu45forwardFormat {}
  implicit lazy val MusicxmlBaru45styleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Baru45style] = new DefaultMusicxmlBaru45styleFormat {}
  implicit lazy val MusicxmlRightu45leftu45middleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Rightu45leftu45middle] = new DefaultMusicxmlRightu45leftu45middleFormat {}
  implicit lazy val MusicxmlStartu45stopu45discontinueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45discontinue] = new DefaultMusicxmlStartu45stopu45discontinueFormat {}
  implicit lazy val MusicxmlWingedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Winged] = new DefaultMusicxmlWingedFormat {}
  implicit lazy val MusicxmlBeateru45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beateru45value] = new DefaultMusicxmlBeateru45valueFormat {}
  implicit lazy val MusicxmlDegreeu45symbolu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45symbolu45value] = new DefaultMusicxmlDegreeu45symbolu45valueFormat {}
  implicit lazy val MusicxmlDegreeu45typeu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45typeu45value] = new DefaultMusicxmlDegreeu45typeu45valueFormat {}
  implicit lazy val MusicxmlEffectFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Effect] = new DefaultMusicxmlEffectFormat {}
  implicit lazy val MusicxmlGlassu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Glassu45value] = new DefaultMusicxmlGlassu45valueFormat {}
  implicit lazy val MusicxmlHarmonyu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonyu45type] = new DefaultMusicxmlHarmonyu45typeFormat {}
  implicit lazy val MusicxmlKindu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Kindu45value] = new DefaultMusicxmlKindu45valueFormat {}
  implicit lazy val MusicxmlLineu45endFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45end] = new DefaultMusicxmlLineu45endFormat {}
  implicit lazy val MusicxmlMeasureu45numberingu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45numberingu45value] = new DefaultMusicxmlMeasureu45numberingu45valueFormat {}
  implicit lazy val MusicxmlMembraneFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Membrane] = new DefaultMusicxmlMembraneFormat {}
  implicit lazy val MusicxmlMetalFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metal] = new DefaultMusicxmlMetalFormat {}
  implicit lazy val MusicxmlOnu45offFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Onu45off] = new DefaultMusicxmlOnu45offFormat {}
  implicit lazy val MusicxmlPedalu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pedalu45type] = new DefaultMusicxmlPedalu45typeFormat {}
  implicit lazy val MusicxmlPitchedu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pitchedu45value] = new DefaultMusicxmlPitchedu45valueFormat {}
  implicit lazy val MusicxmlPrincipalu45voiceu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Principalu45voiceu45symbol] = new DefaultMusicxmlPrincipalu45voiceu45symbolFormat {}
  implicit lazy val MusicxmlStaffu45divideu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45divideu45symbol] = new DefaultMusicxmlStaffu45divideu45symbolFormat {}
  implicit lazy val MusicxmlStartu45stopu45changeu45continueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45changeu45continue] = new DefaultMusicxmlStartu45stopu45changeu45continueFormat {}
  implicit lazy val MusicxmlTipu45directionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tipu45direction] = new DefaultMusicxmlTipu45directionFormat {}
  implicit lazy val MusicxmlSticku45locationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45location] = new DefaultMusicxmlSticku45locationFormat {}
  implicit lazy val MusicxmlSticku45materialFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45material] = new DefaultMusicxmlSticku45materialFormat {}
  implicit lazy val MusicxmlSticku45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45type] = new DefaultMusicxmlSticku45typeFormat {}
  implicit lazy val MusicxmlUpu45downu45stopu45continueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Upu45downu45stopu45continue] = new DefaultMusicxmlUpu45downu45stopu45continueFormat {}
  implicit lazy val MusicxmlWedgeu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Wedgeu45type] = new DefaultMusicxmlWedgeu45typeFormat {}
  implicit lazy val MusicxmlWoodFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Wood] = new DefaultMusicxmlWoodFormat {}
  implicit lazy val MusicxmlMarginu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Marginu45type] = new DefaultMusicxmlMarginu45typeFormat {}
  implicit lazy val MusicxmlNoteu45sizeu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45sizeu45type] = new DefaultMusicxmlNoteu45sizeu45typeFormat {}
  implicit lazy val MusicxmlAccidentalu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45value] = new DefaultMusicxmlAccidentalu45valueFormat {}
  implicit lazy val MusicxmlArrowu45directionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Arrowu45direction] = new DefaultMusicxmlArrowu45directionFormat {}
  implicit lazy val MusicxmlArrowu45styleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Arrowu45style] = new DefaultMusicxmlArrowu45styleFormat {}
  implicit lazy val MusicxmlBeamu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beamu45value] = new DefaultMusicxmlBeamu45valueFormat {}
  implicit lazy val MusicxmlBreathu45marku45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Breathu45marku45value] = new DefaultMusicxmlBreathu45marku45valueFormat {}
  implicit lazy val MusicxmlCaesurau45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Caesurau45value] = new DefaultMusicxmlCaesurau45valueFormat {}
  implicit lazy val MusicxmlCircularu45arrowFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Circularu45arrow] = new DefaultMusicxmlCircularu45arrowFormat {}
  implicit lazy val MusicxmlFanFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fan] = new DefaultMusicxmlFanFormat {}
  implicit lazy val MusicxmlHandbellu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Handbellu45value] = new DefaultMusicxmlHandbellu45valueFormat {}
  implicit lazy val MusicxmlHarmonu45closedu45locationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closedu45location] = new DefaultMusicxmlHarmonu45closedu45locationFormat {}
  implicit lazy val MusicxmlHarmonu45closedu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closedu45value] = new DefaultMusicxmlHarmonu45closedu45valueFormat {}
  implicit lazy val MusicxmlHoleu45closedu45locationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closedu45location] = new DefaultMusicxmlHoleu45closedu45locationFormat {}
  implicit lazy val MusicxmlHoleu45closedu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closedu45value] = new DefaultMusicxmlHoleu45closedu45valueFormat {}
  implicit lazy val MusicxmlNoteu45typeu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45typeu45value] = new DefaultMusicxmlNoteu45typeu45valueFormat {}
  implicit lazy val MusicxmlNoteheadu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteheadu45value] = new DefaultMusicxmlNoteheadu45valueFormat {}
  implicit lazy val MusicxmlShowu45tupletFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Showu45tuplet] = new DefaultMusicxmlShowu45tupletFormat {}
  implicit lazy val MusicxmlStemu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Stemu45value] = new DefaultMusicxmlStemu45valueFormat {}
  implicit lazy val MusicxmlStepFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Step] = new DefaultMusicxmlStepFormat {}
  implicit lazy val MusicxmlSyllabicFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Syllabic] = new DefaultMusicxmlSyllabicFormat {}
  implicit lazy val MusicxmlTapu45handFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tapu45hand] = new DefaultMusicxmlTapu45handFormat {}
  implicit lazy val MusicxmlGroupu45barlineu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45barlineu45value] = new DefaultMusicxmlGroupu45barlineu45valueFormat {}
  implicit lazy val MusicxmlGroupu45symbolu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45symbolu45value] = new DefaultMusicxmlGroupu45symbolu45valueFormat {}
  implicit lazy val MusicxmlAccidentalu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45text] = new DefaultMusicxmlAccidentalu45textFormat {}
  implicit lazy val MusicxmlCodaFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Coda] = new DefaultMusicxmlCodaFormat {}
  implicit lazy val MusicxmlDynamicsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Dynamics] = new DefaultMusicxmlDynamicsFormat {}
  implicit lazy val MusicxmlEmptyFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Empty] = new DefaultMusicxmlEmptyFormat {}
  implicit lazy val MusicxmlEmptyu45placementableFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placementable] = new DefaultMusicxmlEmptyu45placementableFormat {}
  implicit lazy val MusicxmlEmptyu45placementFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placement] = new DefaultMusicxmlEmptyu45placementFormat {}
  implicit lazy val MusicxmlEmptyu45placementu45smuflFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placementu45smufl] = new DefaultMusicxmlEmptyu45placementu45smuflFormat {}
  implicit lazy val MusicxmlEmptyu45printu45styleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45style] = new DefaultMusicxmlEmptyu45printu45styleFormat {}
  implicit lazy val MusicxmlEmptyu45printu45styleu45alignFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45styleu45align] = new DefaultMusicxmlEmptyu45printu45styleu45alignFormat {}
  implicit lazy val MusicxmlEmptyu45printu45styleu45alignu45idFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id] = new DefaultMusicxmlEmptyu45printu45styleu45alignu45idFormat {}
  implicit lazy val MusicxmlEmptyu45printu45objectu45styleu45alignFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align] = new DefaultMusicxmlEmptyu45printu45objectu45styleu45alignFormat {}
  implicit lazy val MusicxmlEmptyu45trillu45soundableFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45trillu45soundable] = new DefaultMusicxmlEmptyu45trillu45soundableFormat {}
  implicit lazy val MusicxmlEmptyu45trillu45soundFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45trillu45sound] = new DefaultMusicxmlEmptyu45trillu45soundFormat {}
  implicit lazy val MusicxmlHorizontalu45turnFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Horizontalu45turn] = new DefaultMusicxmlHorizontalu45turnFormat {}
  implicit lazy val MusicxmlFermataFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fermata] = new DefaultMusicxmlFermataFormat {}
  implicit lazy val MusicxmlFingeringFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fingering] = new DefaultMusicxmlFingeringFormat {}
  implicit lazy val MusicxmlFormattedu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45symbol] = new DefaultMusicxmlFormattedu45symbolFormat {}
  implicit lazy val MusicxmlFormattedu45symbolu45idFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45symbolu45id] = new DefaultMusicxmlFormattedu45symbolu45idFormat {}
  implicit lazy val MusicxmlFormattedu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45text] = new DefaultMusicxmlFormattedu45textFormat {}
  implicit lazy val MusicxmlFormattedu45textu45idFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45textu45id] = new DefaultMusicxmlFormattedu45textu45idFormat {}
  implicit lazy val MusicxmlFretFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fret] = new DefaultMusicxmlFretFormat {}
  implicit lazy val MusicxmlLevelFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Level] = new DefaultMusicxmlLevelFormat {}
  implicit lazy val MusicxmlMidiu45deviceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Midiu45device] = new DefaultMusicxmlMidiu45deviceFormat {}
  implicit lazy val MusicxmlMidiu45instrumentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Midiu45instrument] = new DefaultMusicxmlMidiu45instrumentFormat {}
  implicit lazy val MusicxmlNameu45displayFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Nameu45display] = new DefaultMusicxmlNameu45displayFormat {}
  implicit lazy val MusicxmlOtheru45playFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45play] = new DefaultMusicxmlOtheru45playFormat {}
  implicit lazy val MusicxmlPlayFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Play] = new DefaultMusicxmlPlayFormat {}
  implicit lazy val MusicxmlSegnoFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Segno] = new DefaultMusicxmlSegnoFormat {}
  implicit lazy val MusicxmlStringTypeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.StringType] = new DefaultMusicxmlStringTypeFormat {}
  implicit lazy val MusicxmlTypedu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Typedu45text] = new DefaultMusicxmlTypedu45textFormat {}
  implicit lazy val MusicxmlWavyu45lineFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Wavyu45line] = new DefaultMusicxmlWavyu45lineFormat {}
  implicit lazy val MusicxmlDirectiveFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Directive] = new DefaultMusicxmlDirectiveFormat {}
  implicit lazy val MusicxmlAttributesTypeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.AttributesType] = new DefaultMusicxmlAttributesTypeFormat {}
  implicit lazy val MusicxmlBeatu45repeatFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beatu45repeat] = new DefaultMusicxmlBeatu45repeatFormat {}
  implicit lazy val MusicxmlCancelFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Cancel] = new DefaultMusicxmlCancelFormat {}
  implicit lazy val MusicxmlClefFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Clef] = new DefaultMusicxmlClefFormat {}
  implicit lazy val MusicxmlInterchangeableFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Interchangeable] = new DefaultMusicxmlInterchangeableFormat {}
  implicit lazy val MusicxmlKeyFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Key] = new DefaultMusicxmlKeyFormat {}
  implicit lazy val MusicxmlKeyu45accidentalFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Keyu45accidental] = new DefaultMusicxmlKeyu45accidentalFormat {}
  implicit lazy val MusicxmlKeyu45octaveFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Keyu45octave] = new DefaultMusicxmlKeyu45octaveFormat {}
  implicit lazy val MusicxmlMeasureu45repeatFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45repeat] = new DefaultMusicxmlMeasureu45repeatFormat {}
  implicit lazy val MusicxmlMeasureu45styleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45style] = new DefaultMusicxmlMeasureu45styleFormat {}
  implicit lazy val MusicxmlMultipleu45restFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Multipleu45rest] = new DefaultMusicxmlMultipleu45restFormat {}
  implicit lazy val MusicxmlPartu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Partu45symbol] = new DefaultMusicxmlPartu45symbolFormat {}
  implicit lazy val MusicxmlSlashFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Slash] = new DefaultMusicxmlSlashFormat {}
  implicit lazy val MusicxmlStaffu45detailsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45details] = new DefaultMusicxmlStaffu45detailsFormat {}
  implicit lazy val MusicxmlStaffu45tuningFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45tuning] = new DefaultMusicxmlStaffu45tuningFormat {}
  implicit lazy val MusicxmlTimeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Time] = new DefaultMusicxmlTimeFormat {}
  implicit lazy val MusicxmlTimeSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.TimeSequence1] = new DefaultMusicxmlTimeSequence1Format {}
  implicit lazy val MusicxmlTransposeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Transpose] = new DefaultMusicxmlTransposeFormat {}
  implicit lazy val MusicxmlBaru45styleu45colorFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Baru45styleu45color] = new DefaultMusicxmlBaru45styleu45colorFormat {}
  implicit lazy val MusicxmlBarlineFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Barline] = new DefaultMusicxmlBarlineFormat {}
  implicit lazy val MusicxmlEndingFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Ending] = new DefaultMusicxmlEndingFormat {}
  implicit lazy val MusicxmlRepeatFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Repeat] = new DefaultMusicxmlRepeatFormat {}
  implicit lazy val MusicxmlAccordFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accord] = new DefaultMusicxmlAccordFormat {}
  implicit lazy val MusicxmlAccordionu45registrationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accordionu45registration] = new DefaultMusicxmlAccordionu45registrationFormat {}
  implicit lazy val MusicxmlBarreFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Barre] = new DefaultMusicxmlBarreFormat {}
  implicit lazy val MusicxmlBassFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bass] = new DefaultMusicxmlBassFormat {}
  implicit lazy val MusicxmlBassu45alterFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bassu45alter] = new DefaultMusicxmlBassu45alterFormat {}
  implicit lazy val MusicxmlBassu45stepFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bassu45step] = new DefaultMusicxmlBassu45stepFormat {}
  implicit lazy val MusicxmlBeaterFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beater] = new DefaultMusicxmlBeaterFormat {}
  implicit lazy val MusicxmlBeatu45unitu45tiedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beatu45unitu45tied] = new DefaultMusicxmlBeatu45unitu45tiedFormat {}
  implicit lazy val MusicxmlBracketFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bracket] = new DefaultMusicxmlBracketFormat {}
  implicit lazy val MusicxmlDashesFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Dashes] = new DefaultMusicxmlDashesFormat {}
  implicit lazy val MusicxmlDegreeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degree] = new DefaultMusicxmlDegreeFormat {}
  implicit lazy val MusicxmlDegreeu45alterFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45alter] = new DefaultMusicxmlDegreeu45alterFormat {}
  implicit lazy val MusicxmlDegreeu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45type] = new DefaultMusicxmlDegreeu45typeFormat {}
  implicit lazy val MusicxmlDegreeu45valueFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45value] = new DefaultMusicxmlDegreeu45valueFormat {}
  implicit lazy val MusicxmlDirectionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Direction] = new DefaultMusicxmlDirectionFormat {}
  implicit lazy val MusicxmlDirectionu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Directionu45type] = new DefaultMusicxmlDirectionu45typeFormat {}
  implicit lazy val MusicxmlFeatureFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Feature] = new DefaultMusicxmlFeatureFormat {}
  implicit lazy val MusicxmlFirstu45fretFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Firstu45fret] = new DefaultMusicxmlFirstu45fretFormat {}
  implicit lazy val MusicxmlFrameFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Frame] = new DefaultMusicxmlFrameFormat {}
  implicit lazy val MusicxmlFrameu45noteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Frameu45note] = new DefaultMusicxmlFrameu45noteFormat {}
  implicit lazy val MusicxmlGlassFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Glass] = new DefaultMusicxmlGlassFormat {}
  implicit lazy val MusicxmlGroupingFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Grouping] = new DefaultMusicxmlGroupingFormat {}
  implicit lazy val MusicxmlHarmonyFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmony] = new DefaultMusicxmlHarmonyFormat {}
  implicit lazy val MusicxmlHarpu45pedalsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harpu45pedals] = new DefaultMusicxmlHarpu45pedalsFormat {}
  implicit lazy val MusicxmlImageFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Image] = new DefaultMusicxmlImageFormat {}
  implicit lazy val MusicxmlInversionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Inversion] = new DefaultMusicxmlInversionFormat {}
  implicit lazy val MusicxmlKindFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Kind] = new DefaultMusicxmlKindFormat {}
  implicit lazy val MusicxmlMeasureu45numberingFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45numbering] = new DefaultMusicxmlMeasureu45numberingFormat {}
  implicit lazy val MusicxmlMetronomeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metronome] = new DefaultMusicxmlMetronomeFormat {}
  implicit lazy val MusicxmlMetronomeSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence1] = new DefaultMusicxmlMetronomeSequence1Format {}
  implicit lazy val MusicxmlMetronomeSequence2Format: scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence2] = new DefaultMusicxmlMetronomeSequence2Format {}
  implicit lazy val MusicxmlMetronomeSequence3Format: scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence3] = new DefaultMusicxmlMetronomeSequence3Format {}
  implicit lazy val MusicxmlMetronomeSequence4Format: scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence4] = new DefaultMusicxmlMetronomeSequence4Format {}
  implicit lazy val MusicxmlMetronomeu45beamFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45beam] = new DefaultMusicxmlMetronomeu45beamFormat {}
  implicit lazy val MusicxmlMetronomeu45noteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45note] = new DefaultMusicxmlMetronomeu45noteFormat {}
  implicit lazy val MusicxmlMetronomeu45tiedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45tied] = new DefaultMusicxmlMetronomeu45tiedFormat {}
  implicit lazy val MusicxmlMetronomeu45tupletFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45tuplet] = new DefaultMusicxmlMetronomeu45tupletFormat {}
  implicit lazy val MusicxmlOctaveu45shiftFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Octaveu45shift] = new DefaultMusicxmlOctaveu45shiftFormat {}
  implicit lazy val MusicxmlOffsetFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Offset] = new DefaultMusicxmlOffsetFormat {}
  implicit lazy val MusicxmlOtheru45directionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45direction] = new DefaultMusicxmlOtheru45directionFormat {}
  implicit lazy val MusicxmlPedalFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pedal] = new DefaultMusicxmlPedalFormat {}
  implicit lazy val MusicxmlPedalu45tuningFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pedalu45tuning] = new DefaultMusicxmlPedalu45tuningFormat {}
  implicit lazy val MusicxmlPeru45minuteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Peru45minute] = new DefaultMusicxmlPeru45minuteFormat {}
  implicit lazy val MusicxmlPercussionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Percussion] = new DefaultMusicxmlPercussionFormat {}
  implicit lazy val MusicxmlPitchedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pitched] = new DefaultMusicxmlPitchedFormat {}
  implicit lazy val MusicxmlPrincipalu45voiceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Principalu45voice] = new DefaultMusicxmlPrincipalu45voiceFormat {}
  implicit lazy val MusicxmlPrintFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Print] = new DefaultMusicxmlPrintFormat {}
  implicit lazy val MusicxmlRootFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Root] = new DefaultMusicxmlRootFormat {}
  implicit lazy val MusicxmlRootu45alterFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Rootu45alter] = new DefaultMusicxmlRootu45alterFormat {}
  implicit lazy val MusicxmlRootu45stepFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Rootu45step] = new DefaultMusicxmlRootu45stepFormat {}
  implicit lazy val MusicxmlScordaturaFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scordatura] = new DefaultMusicxmlScordaturaFormat {}
  implicit lazy val MusicxmlSoundFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Sound] = new DefaultMusicxmlSoundFormat {}
  implicit lazy val MusicxmlSoundSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.SoundSequence1] = new DefaultMusicxmlSoundSequence1Format {}
  implicit lazy val MusicxmlStaffu45divideFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45divide] = new DefaultMusicxmlStaffu45divideFormat {}
  implicit lazy val MusicxmlStickFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Stick] = new DefaultMusicxmlStickFormat {}
  implicit lazy val MusicxmlStringu45muteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Stringu45mute] = new DefaultMusicxmlStringu45muteFormat {}
  implicit lazy val MusicxmlWedgeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Wedge] = new DefaultMusicxmlWedgeFormat {}
  implicit lazy val MusicxmlEncodingFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Encoding] = new DefaultMusicxmlEncodingFormat {}
  implicit lazy val MusicxmlIdentificationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Identification] = new DefaultMusicxmlIdentificationFormat {}
  implicit lazy val MusicxmlMiscellaneousFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Miscellaneous] = new DefaultMusicxmlMiscellaneousFormat {}
  implicit lazy val MusicxmlMiscellaneousu45fieldFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Miscellaneousu45field] = new DefaultMusicxmlMiscellaneousu45fieldFormat {}
  implicit lazy val MusicxmlSupportsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Supports] = new DefaultMusicxmlSupportsFormat {}
  implicit lazy val MusicxmlAppearanceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Appearance] = new DefaultMusicxmlAppearanceFormat {}
  implicit lazy val MusicxmlDistanceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Distance] = new DefaultMusicxmlDistanceFormat {}
  implicit lazy val MusicxmlGlyphFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Glyph] = new DefaultMusicxmlGlyphFormat {}
  implicit lazy val MusicxmlLineu45widthFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45width] = new DefaultMusicxmlLineu45widthFormat {}
  implicit lazy val MusicxmlMeasureu45layoutFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45layout] = new DefaultMusicxmlMeasureu45layoutFormat {}
  implicit lazy val MusicxmlNoteu45sizeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45size] = new DefaultMusicxmlNoteu45sizeFormat {}
  implicit lazy val MusicxmlOtheru45appearanceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45appearance] = new DefaultMusicxmlOtheru45appearanceFormat {}
  implicit lazy val MusicxmlPageu45layoutFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pageu45layout] = new DefaultMusicxmlPageu45layoutFormat {}
  implicit lazy val MusicxmlPageu45layoutSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.Pageu45layoutSequence1] = new DefaultMusicxmlPageu45layoutSequence1Format {}
  implicit lazy val MusicxmlPageu45marginsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pageu45margins] = new DefaultMusicxmlPageu45marginsFormat {}
  implicit lazy val MusicxmlScalingFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scaling] = new DefaultMusicxmlScalingFormat {}
  implicit lazy val MusicxmlStaffu45layoutFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45layout] = new DefaultMusicxmlStaffu45layoutFormat {}
  implicit lazy val MusicxmlSystemu45dividersFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Systemu45dividers] = new DefaultMusicxmlSystemu45dividersFormat {}
  implicit lazy val MusicxmlSystemu45layoutFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Systemu45layout] = new DefaultMusicxmlSystemu45layoutFormat {}
  implicit lazy val MusicxmlSystemu45marginsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Systemu45margins] = new DefaultMusicxmlSystemu45marginsFormat {}
  implicit lazy val MusicxmlBookmarkFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bookmark] = new DefaultMusicxmlBookmarkFormat {}
  implicit lazy val MusicxmlLinkFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Link] = new DefaultMusicxmlLinkFormat {}
  implicit lazy val MusicxmlAccidentalFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accidental] = new DefaultMusicxmlAccidentalFormat {}
  implicit lazy val MusicxmlAccidentalu45markFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45mark] = new DefaultMusicxmlAccidentalu45markFormat {}
  implicit lazy val MusicxmlArpeggiateFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Arpeggiate] = new DefaultMusicxmlArpeggiateFormat {}
  implicit lazy val MusicxmlArticulationsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Articulations] = new DefaultMusicxmlArticulationsFormat {}
  implicit lazy val MusicxmlArrowFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Arrow] = new DefaultMusicxmlArrowFormat {}
  implicit lazy val MusicxmlArrowSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.ArrowSequence1] = new DefaultMusicxmlArrowSequence1Format {}
  implicit lazy val MusicxmlBackupFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Backup] = new DefaultMusicxmlBackupFormat {}
  implicit lazy val MusicxmlBeamFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beam] = new DefaultMusicxmlBeamFormat {}
  implicit lazy val MusicxmlBendFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Bend] = new DefaultMusicxmlBendFormat {}
  implicit lazy val MusicxmlBreathu45markFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Breathu45mark] = new DefaultMusicxmlBreathu45markFormat {}
  implicit lazy val MusicxmlCaesuraFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Caesura] = new DefaultMusicxmlCaesuraFormat {}
  implicit lazy val MusicxmlElisionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Elision] = new DefaultMusicxmlElisionFormat {}
  implicit lazy val MusicxmlEmptyu45lineFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45line] = new DefaultMusicxmlEmptyu45lineFormat {}
  implicit lazy val MusicxmlExtendFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Extend] = new DefaultMusicxmlExtendFormat {}
  implicit lazy val MusicxmlFigureFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Figure] = new DefaultMusicxmlFigureFormat {}
  implicit lazy val MusicxmlFiguredu45bassFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Figuredu45bass] = new DefaultMusicxmlFiguredu45bassFormat {}
  implicit lazy val MusicxmlForwardFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Forward] = new DefaultMusicxmlForwardFormat {}
  implicit lazy val MusicxmlGlissandoFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Glissando] = new DefaultMusicxmlGlissandoFormat {}
  implicit lazy val MusicxmlGraceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Grace] = new DefaultMusicxmlGraceFormat {}
  implicit lazy val MusicxmlHammeru45onu45pullu45offFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Hammeru45onu45pullu45off] = new DefaultMusicxmlHammeru45onu45pullu45offFormat {}
  implicit lazy val MusicxmlHandbellFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Handbell] = new DefaultMusicxmlHandbellFormat {}
  implicit lazy val MusicxmlHarmonu45closedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closed] = new DefaultMusicxmlHarmonu45closedFormat {}
  implicit lazy val MusicxmlHarmonu45muteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45mute] = new DefaultMusicxmlHarmonu45muteFormat {}
  implicit lazy val MusicxmlHarmonicFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonic] = new DefaultMusicxmlHarmonicFormat {}
  implicit lazy val MusicxmlHeelu45toeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Heelu45toe] = new DefaultMusicxmlHeelu45toeFormat {}
  implicit lazy val MusicxmlHoleFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Hole] = new DefaultMusicxmlHoleFormat {}
  implicit lazy val MusicxmlHoleu45closedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closed] = new DefaultMusicxmlHoleu45closedFormat {}
  implicit lazy val MusicxmlInstrumentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Instrument] = new DefaultMusicxmlInstrumentFormat {}
  implicit lazy val MusicxmlLyricFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lyric] = new DefaultMusicxmlLyricFormat {}
  implicit lazy val MusicxmlLyricSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence1] = new DefaultMusicxmlLyricSequence1Format {}
  implicit lazy val MusicxmlLyricSequence2Format: scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence2] = new DefaultMusicxmlLyricSequence2Format {}
  implicit lazy val MusicxmlLyricSequence3Format: scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence3] = new DefaultMusicxmlLyricSequence3Format {}
  implicit lazy val MusicxmlMordentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Mordent] = new DefaultMusicxmlMordentFormat {}
  implicit lazy val MusicxmlNonu45arpeggiateFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Nonu45arpeggiate] = new DefaultMusicxmlNonu45arpeggiateFormat {}
  implicit lazy val MusicxmlNotationsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Notations] = new DefaultMusicxmlNotationsFormat {}
  implicit lazy val MusicxmlNoteFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Note] = new DefaultMusicxmlNoteFormat {}
  implicit lazy val MusicxmlNoteSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence1] = new DefaultMusicxmlNoteSequence1Format {}
  implicit lazy val MusicxmlNoteSequence2Format: scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence2] = new DefaultMusicxmlNoteSequence2Format {}
  implicit lazy val MusicxmlNoteSequence3Format: scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence3] = new DefaultMusicxmlNoteSequence3Format {}
  implicit lazy val MusicxmlNoteSequence4Format: scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence4] = new DefaultMusicxmlNoteSequence4Format {}
  implicit lazy val MusicxmlNoteSequence5Format: scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence5] = new DefaultMusicxmlNoteSequence5Format {}
  implicit lazy val MusicxmlNoteu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45type] = new DefaultMusicxmlNoteu45typeFormat {}
  implicit lazy val MusicxmlNoteheadFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Notehead] = new DefaultMusicxmlNoteheadFormat {}
  implicit lazy val MusicxmlNoteheadu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Noteheadu45text] = new DefaultMusicxmlNoteheadu45textFormat {}
  implicit lazy val MusicxmlOrnamentsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Ornaments] = new DefaultMusicxmlOrnamentsFormat {}
  implicit lazy val MusicxmlOrnamentsSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.OrnamentsSequence1] = new DefaultMusicxmlOrnamentsSequence1Format {}
  implicit lazy val MusicxmlOtheru45notationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45notation] = new DefaultMusicxmlOtheru45notationFormat {}
  implicit lazy val MusicxmlOtheru45placementu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45placementu45text] = new DefaultMusicxmlOtheru45placementu45textFormat {}
  implicit lazy val MusicxmlOtheru45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45text] = new DefaultMusicxmlOtheru45textFormat {}
  implicit lazy val MusicxmlPitchFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Pitch] = new DefaultMusicxmlPitchFormat {}
  implicit lazy val MusicxmlPlacementu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Placementu45text] = new DefaultMusicxmlPlacementu45textFormat {}
  implicit lazy val MusicxmlRestFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Rest] = new DefaultMusicxmlRestFormat {}
  implicit lazy val MusicxmlSlideFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Slide] = new DefaultMusicxmlSlideFormat {}
  implicit lazy val MusicxmlSlurFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Slur] = new DefaultMusicxmlSlurFormat {}
  implicit lazy val MusicxmlStemFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Stem] = new DefaultMusicxmlStemFormat {}
  implicit lazy val MusicxmlStrongu45accentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Strongu45accent] = new DefaultMusicxmlStrongu45accentFormat {}
  implicit lazy val MusicxmlStyleu45textFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Styleu45text] = new DefaultMusicxmlStyleu45textFormat {}
  implicit lazy val MusicxmlTapFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tap] = new DefaultMusicxmlTapFormat {}
  implicit lazy val MusicxmlTechnicalFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Technical] = new DefaultMusicxmlTechnicalFormat {}
  implicit lazy val MusicxmlTextu45elementu45dataFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Textu45elementu45data] = new DefaultMusicxmlTextu45elementu45dataFormat {}
  implicit lazy val MusicxmlTieFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tie] = new DefaultMusicxmlTieFormat {}
  implicit lazy val MusicxmlTiedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tied] = new DefaultMusicxmlTiedFormat {}
  implicit lazy val MusicxmlTimeu45modificationableFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45modificationable] = new DefaultMusicxmlTimeu45modificationableFormat {}
  implicit lazy val MusicxmlTimeu45modificationFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45modification] = new DefaultMusicxmlTimeu45modificationFormat {}
  implicit lazy val MusicxmlTimeu45modificationableSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45modificationableSequence1] = new DefaultMusicxmlTimeu45modificationableSequence1Format {}
  implicit lazy val MusicxmlTremoloFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tremolo] = new DefaultMusicxmlTremoloFormat {}
  implicit lazy val MusicxmlTupletFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tuplet] = new DefaultMusicxmlTupletFormat {}
  implicit lazy val MusicxmlTupletu45dotFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45dot] = new DefaultMusicxmlTupletu45dotFormat {}
  implicit lazy val MusicxmlTupletu45numberFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45number] = new DefaultMusicxmlTupletu45numberFormat {}
  implicit lazy val MusicxmlTupletu45portionFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45portion] = new DefaultMusicxmlTupletu45portionFormat {}
  implicit lazy val MusicxmlTupletu45typeFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45type] = new DefaultMusicxmlTupletu45typeFormat {}
  implicit lazy val MusicxmlUnpitchedFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Unpitched] = new DefaultMusicxmlUnpitchedFormat {}
  implicit lazy val MusicxmlCreditFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Credit] = new DefaultMusicxmlCreditFormat {}
  implicit lazy val MusicxmlCreditSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.CreditSequence1] = new DefaultMusicxmlCreditSequence1Format {}
  implicit lazy val MusicxmlCreditSequence2Format: scalaxb.XMLFormat[com.fdilke.musicxml.CreditSequence2] = new DefaultMusicxmlCreditSequence2Format {}
  implicit lazy val MusicxmlDefaultsFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Defaults] = new DefaultMusicxmlDefaultsFormat {}
  implicit lazy val MusicxmlEmptyu45fontFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45font] = new DefaultMusicxmlEmptyu45fontFormat {}
  implicit lazy val MusicxmlGroupu45barlineFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45barline] = new DefaultMusicxmlGroupu45barlineFormat {}
  implicit lazy val MusicxmlGroupu45nameFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45name] = new DefaultMusicxmlGroupu45nameFormat {}
  implicit lazy val MusicxmlGroupu45symbolFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45symbol] = new DefaultMusicxmlGroupu45symbolFormat {}
  implicit lazy val MusicxmlLyricu45fontFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lyricu45font] = new DefaultMusicxmlLyricu45fontFormat {}
  implicit lazy val MusicxmlLyricu45languageFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Lyricu45language] = new DefaultMusicxmlLyricu45languageFormat {}
  implicit lazy val MusicxmlOpusFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Opus] = new DefaultMusicxmlOpusFormat {}
  implicit lazy val MusicxmlPartu45groupFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Partu45group] = new DefaultMusicxmlPartu45groupFormat {}
  implicit lazy val MusicxmlPartu45listFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Partu45list] = new DefaultMusicxmlPartu45listFormat {}
  implicit lazy val MusicxmlPartu45nameFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Partu45name] = new DefaultMusicxmlPartu45nameFormat {}
  implicit lazy val MusicxmlScoreu45instrumentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45instrument] = new DefaultMusicxmlScoreu45instrumentFormat {}
  implicit lazy val MusicxmlScoreu45partFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45part] = new DefaultMusicxmlScoreu45partFormat {}
  implicit lazy val MusicxmlScoreu45partSequence1Format: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45partSequence1] = new DefaultMusicxmlScoreu45partSequence1Format {}
  implicit lazy val MusicxmlVirtualu45instrumentFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Virtualu45instrument] = new DefaultMusicxmlVirtualu45instrumentFormat {}
  implicit lazy val MusicxmlWorkFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Work] = new DefaultMusicxmlWorkFormat {}
  implicit lazy val MusicxmlMeasureFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Measure] = new DefaultMusicxmlMeasureFormat {}
  implicit lazy val MusicxmlPartFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Part] = new DefaultMusicxmlPartFormat {}
  implicit lazy val MusicxmlScoreu45partwiseFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45partwise] = new DefaultMusicxmlScoreu45partwiseFormat {}
  implicit lazy val MusicxmlPart2Format: scalaxb.XMLFormat[com.fdilke.musicxml.Part2] = new DefaultMusicxmlPart2Format {}
  implicit lazy val MusicxmlMeasure2Format: scalaxb.XMLFormat[com.fdilke.musicxml.Measure2] = new DefaultMusicxmlMeasure2Format {}
  implicit lazy val MusicxmlScoreu45timewiseFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45timewise] = new DefaultMusicxmlScoreu45timewiseFormat {}
  implicit lazy val MusicxmlScoreu45partSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45partSequence] = new DefaultMusicxmlScoreu45partSequenceFormat {}
  implicit lazy val MusicxmlScoreu45headerSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45headerSequence] = new DefaultMusicxmlScoreu45headerSequenceFormat {}
  implicit lazy val MusicxmlPartu45groupSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Partu45groupSequence] = new DefaultMusicxmlPartu45groupSequenceFormat {}
  implicit lazy val MusicxmlFullu45noteSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Fullu45noteSequence] = new DefaultMusicxmlFullu45noteSequenceFormat {}
  implicit lazy val MusicxmlDisplayu45stepu45octaveSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Displayu45stepu45octaveSequence] = new DefaultMusicxmlDisplayu45stepu45octaveSequenceFormat {}
  implicit lazy val MusicxmlDurationSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.DurationSequence] = new DefaultMusicxmlDurationSequenceFormat {}
  implicit lazy val MusicxmlLeftu45rightu45marginsSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45rightu45marginsSequence] = new DefaultMusicxmlLeftu45rightu45marginsSequenceFormat {}
  implicit lazy val MusicxmlLayoutSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.LayoutSequence] = new DefaultMusicxmlLayoutSequenceFormat {}
  implicit lazy val MusicxmlAllu45marginsSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Allu45marginsSequence] = new DefaultMusicxmlAllu45marginsSequenceFormat {}
  implicit lazy val MusicxmlHarmonyu45chordSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Harmonyu45chordSequence] = new DefaultMusicxmlHarmonyu45chordSequenceFormat {}
  implicit lazy val MusicxmlBeatu45unitSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Beatu45unitSequence] = new DefaultMusicxmlBeatu45unitSequenceFormat {}
  implicit lazy val MusicxmlTraditionalu45keySequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Traditionalu45keySequence] = new DefaultMusicxmlTraditionalu45keySequenceFormat {}
  implicit lazy val MusicxmlTimeu45signatureSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45signatureSequence] = new DefaultMusicxmlTimeu45signatureSequenceFormat {}
  implicit lazy val MusicxmlSlashSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.SlashSequence] = new DefaultMusicxmlSlashSequenceFormat {}
  implicit lazy val MusicxmlSlashSequence2Format: scalaxb.XMLFormat[com.fdilke.musicxml.SlashSequence2] = new DefaultMusicxmlSlashSequence2Format {}
  implicit lazy val MusicxmlNonu45traditionalu45keySequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Nonu45traditionalu45keySequence] = new DefaultMusicxmlNonu45traditionalu45keySequenceFormat {}
  implicit lazy val MusicxmlVoiceSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.VoiceSequence] = new DefaultMusicxmlVoiceSequenceFormat {}
  implicit lazy val MusicxmlTuningSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.TuningSequence] = new DefaultMusicxmlTuningSequenceFormat {}
  implicit lazy val MusicxmlStaffSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.StaffSequence] = new DefaultMusicxmlStaffSequenceFormat {}
  implicit lazy val MusicxmlLevelSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.LevelSequence] = new DefaultMusicxmlLevelSequenceFormat {}
  implicit lazy val MusicxmlFootnoteSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.FootnoteSequence] = new DefaultMusicxmlFootnoteSequenceFormat {}
  implicit lazy val MusicxmlEditorialu45voiceu45directionSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Editorialu45voiceu45directionSequence] = new DefaultMusicxmlEditorialu45voiceu45directionSequenceFormat {}
  implicit lazy val MusicxmlEditorialu45voiceSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.Editorialu45voiceSequence] = new DefaultMusicxmlEditorialu45voiceSequenceFormat {}
  implicit lazy val MusicxmlEditorialSequenceFormat: scalaxb.XMLFormat[com.fdilke.musicxml.EditorialSequence] = new DefaultMusicxmlEditorialSequenceFormat {}
  implicit lazy val MusicxmlPartu45nameu45textFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Partu45nameu45text] = new DefaultMusicxmlPartu45nameu45textFormat {}
  implicit lazy val MusicxmlPartu45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Partu45attributes] = new DefaultMusicxmlPartu45attributesFormat {}
  implicit lazy val MusicxmlMeasureu45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Measureu45attributes] = new DefaultMusicxmlMeasureu45attributesFormat {}
  implicit lazy val MusicxmlGroupu45nameu45textFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Groupu45nameu45text] = new DefaultMusicxmlGroupu45nameu45textFormat {}
  implicit lazy val MusicxmlLinku45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Linku45attributes] = new DefaultMusicxmlLinku45attributesFormat {}
  implicit lazy val MusicxmlElementu45positionFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Elementu45position] = new DefaultMusicxmlElementu45positionFormat {}
  implicit lazy val MusicxmlPrintu45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45attributes] = new DefaultMusicxmlPrintu45attributesFormat {}
  implicit lazy val MusicxmlImageu45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Imageu45attributes] = new DefaultMusicxmlImageu45attributesFormat {}
  implicit lazy val MusicxmlYu45positionFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Yu45position] = new DefaultMusicxmlYu45positionFormat {}
  implicit lazy val MusicxmlXu45positionFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Xu45position] = new DefaultMusicxmlXu45positionFormat {}
  implicit lazy val MusicxmlValignu45imageTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Valignu45imageType] = new DefaultMusicxmlValignu45imageTypeFormat {}
  implicit lazy val MusicxmlValignTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.ValignType] = new DefaultMusicxmlValignTypeFormat {}
  implicit lazy val MusicxmlTrillu45soundFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Trillu45sound] = new DefaultMusicxmlTrillu45soundFormat {}
  implicit lazy val MusicxmlTextu45rotationFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45rotation] = new DefaultMusicxmlTextu45rotationFormat {}
  implicit lazy val MusicxmlTextu45formattingFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45formatting] = new DefaultMusicxmlTextu45formattingFormat {}
  implicit lazy val MusicxmlTextu45directionTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45directionType] = new DefaultMusicxmlTextu45directionTypeFormat {}
  implicit lazy val MusicxmlTextu45decorationFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45decoration] = new DefaultMusicxmlTextu45decorationFormat {}
  implicit lazy val MusicxmlSymbolu45formattingFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Symbolu45formatting] = new DefaultMusicxmlSymbolu45formattingFormat {}
  implicit lazy val MusicxmlSmuflFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Smufl] = new DefaultMusicxmlSmuflFormat {}
  implicit lazy val MusicxmlPrintoutFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printout] = new DefaultMusicxmlPrintoutFormat {}
  implicit lazy val MusicxmlPrintu45styleu45alignFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45styleu45align] = new DefaultMusicxmlPrintu45styleu45alignFormat {}
  implicit lazy val MusicxmlPrintu45styleFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45style] = new DefaultMusicxmlPrintu45styleFormat {}
  implicit lazy val MusicxmlPrintu45spacingFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45spacing] = new DefaultMusicxmlPrintu45spacingFormat {}
  implicit lazy val MusicxmlPrintu45objectFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45object] = new DefaultMusicxmlPrintu45objectFormat {}
  implicit lazy val MusicxmlPositionFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Position] = new DefaultMusicxmlPositionFormat {}
  implicit lazy val MusicxmlPlacementFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Placement] = new DefaultMusicxmlPlacementFormat {}
  implicit lazy val MusicxmlOrientationFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Orientation] = new DefaultMusicxmlOrientationFormat {}
  implicit lazy val MusicxmlOptionalu45uniqueu45idFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Optionalu45uniqueu45id] = new DefaultMusicxmlOptionalu45uniqueu45idFormat {}
  implicit lazy val MusicxmlLineu45typeTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45typeType] = new DefaultMusicxmlLineu45typeTypeFormat {}
  implicit lazy val MusicxmlLineu45shapeTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45shapeType] = new DefaultMusicxmlLineu45shapeTypeFormat {}
  implicit lazy val MusicxmlLineu45lengthTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45lengthType] = new DefaultMusicxmlLineu45lengthTypeFormat {}
  implicit lazy val MusicxmlLineu45heightFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45height] = new DefaultMusicxmlLineu45heightFormat {}
  implicit lazy val MusicxmlLevelu45displayFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Levelu45display] = new DefaultMusicxmlLevelu45displayFormat {}
  implicit lazy val MusicxmlLetteru45spacingFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Letteru45spacing] = new DefaultMusicxmlLetteru45spacingFormat {}
  implicit lazy val MusicxmlJustifyFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Justify] = new DefaultMusicxmlJustifyFormat {}
  implicit lazy val MusicxmlHalignFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Halign] = new DefaultMusicxmlHalignFormat {}
  implicit lazy val MusicxmlFontFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Font] = new DefaultMusicxmlFontFormat {}
  implicit lazy val MusicxmlEnclosureFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Enclosure] = new DefaultMusicxmlEnclosureFormat {}
  implicit lazy val MusicxmlDocumentu45attributesFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Documentu45attributes] = new DefaultMusicxmlDocumentu45attributesFormat {}
  implicit lazy val MusicxmlDirectiveTypeFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.DirectiveType] = new DefaultMusicxmlDirectiveTypeFormat {}
  implicit lazy val MusicxmlDashedu45formattingFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Dashedu45formatting] = new DefaultMusicxmlDashedu45formattingFormat {}
  implicit lazy val MusicxmlColorFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Color] = new DefaultMusicxmlColorFormat {}
  implicit lazy val MusicxmlBezierFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Bezier] = new DefaultMusicxmlBezierFormat {}
  implicit lazy val MusicxmlBendu45soundFormat: scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Bendu45sound] = new DefaultMusicxmlBendu45soundFormat {}

  def buildMusicxmlTypeFormat = new DefaultMusicxmlTypeFormat {}
  trait DefaultMusicxmlTypeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Type] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlShowFormat = new DefaultMusicxmlShowFormat {}
  trait DefaultMusicxmlShowFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Show] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Show] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Show.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Show.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Show, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlActuateFormat = new DefaultMusicxmlActuateFormat {}
  trait DefaultMusicxmlActuateFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Actuate] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Actuate] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Actuate.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Actuate.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Actuate, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlAboveu45belowFormat = new DefaultMusicxmlAboveu45belowFormat {}
  trait DefaultMusicxmlAboveu45belowFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Aboveu45below] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Aboveu45below] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Aboveu45below.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Aboveu45below.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Aboveu45below, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlCssu45fontu45sizeFormat = new DefaultMusicxmlCssu45fontu45sizeFormat {}
  trait DefaultMusicxmlCssu45fontu45sizeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Cssu45fontu45size] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Cssu45fontu45size] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Cssu45fontu45size.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Cssu45fontu45size.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Cssu45fontu45size, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlEnclosureu45shapeFormat = new DefaultMusicxmlEnclosureu45shapeFormat {}
  trait DefaultMusicxmlEnclosureu45shapeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Enclosureu45shape] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Enclosureu45shape] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Enclosureu45shape.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Enclosureu45shape.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Enclosureu45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlFermatau45shapeFormat = new DefaultMusicxmlFermatau45shapeFormat {}
  trait DefaultMusicxmlFermatau45shapeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fermatau45shape] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fermatau45shape] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Fermatau45shape.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Fermatau45shape.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Fermatau45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlFontu45styleFormat = new DefaultMusicxmlFontu45styleFormat {}
  trait DefaultMusicxmlFontu45styleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fontu45style] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fontu45style] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Fontu45style.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Fontu45style.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Fontu45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlFontu45weightFormat = new DefaultMusicxmlFontu45weightFormat {}
  trait DefaultMusicxmlFontu45weightFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fontu45weight] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fontu45weight] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Fontu45weight.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Fontu45weight.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Fontu45weight, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLeftu45centeru45rightFormat = new DefaultMusicxmlLeftu45centeru45rightFormat {}
  trait DefaultMusicxmlLeftu45centeru45rightFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45centeru45right] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Leftu45centeru45right] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Leftu45centeru45right.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Leftu45centeru45right.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Leftu45centeru45right, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLeftu45rightFormat = new DefaultMusicxmlLeftu45rightFormat {}
  trait DefaultMusicxmlLeftu45rightFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45right] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Leftu45right] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Leftu45right.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Leftu45right.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Leftu45right, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLineu45lengthFormat = new DefaultMusicxmlLineu45lengthFormat {}
  trait DefaultMusicxmlLineu45lengthFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45length] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45length] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Lineu45length.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Lineu45length.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Lineu45length, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLineu45shapeFormat = new DefaultMusicxmlLineu45shapeFormat {}
  trait DefaultMusicxmlLineu45shapeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45shape] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45shape] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Lineu45shape.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Lineu45shape.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Lineu45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLineu45typeFormat = new DefaultMusicxmlLineu45typeFormat {}
  trait DefaultMusicxmlLineu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Lineu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Lineu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Lineu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlMuteFormat = new DefaultMusicxmlMuteFormat {}
  trait DefaultMusicxmlMuteFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Mute] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Mute] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Mute.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Mute.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Mute, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlOveru45underFormat = new DefaultMusicxmlOveru45underFormat {}
  trait DefaultMusicxmlOveru45underFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Overu45under] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Overu45under] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Overu45under.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Overu45under.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Overu45under, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSemiu45pitchedFormat = new DefaultMusicxmlSemiu45pitchedFormat {}
  trait DefaultMusicxmlSemiu45pitchedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Semiu45pitched] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Semiu45pitched] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Semiu45pitched.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Semiu45pitched.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Semiu45pitched, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45noteFormat = new DefaultMusicxmlStartu45noteFormat {}
  trait DefaultMusicxmlStartu45noteFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45note] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45note] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45note.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45note.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45note, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45stopFormat = new DefaultMusicxmlStartu45stopFormat {}
  trait DefaultMusicxmlStartu45stopFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stop] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45stop] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45stop.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45stop.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45stop, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45stopu45continueFormat = new DefaultMusicxmlStartu45stopu45continueFormat {}
  trait DefaultMusicxmlStartu45stopu45continueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45continue] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45stopu45continue] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45stopu45continue.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45stopu45continue.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45stopu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45stopu45singleFormat = new DefaultMusicxmlStartu45stopu45singleFormat {}
  trait DefaultMusicxmlStartu45stopu45singleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45single] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45stopu45single] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45stopu45single.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45stopu45single.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45stopu45single, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSymbolu45sizeFormat = new DefaultMusicxmlSymbolu45sizeFormat {}
  trait DefaultMusicxmlSymbolu45sizeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Symbolu45size] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Symbolu45size] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Symbolu45size.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Symbolu45size.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Symbolu45size, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTextu45directionFormat = new DefaultMusicxmlTextu45directionFormat {}
  trait DefaultMusicxmlTextu45directionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Textu45direction] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45direction] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Textu45direction.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Textu45direction.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Textu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTiedu45typeFormat = new DefaultMusicxmlTiedu45typeFormat {}
  trait DefaultMusicxmlTiedu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tiedu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tiedu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Tiedu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Tiedu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Tiedu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTopu45bottomFormat = new DefaultMusicxmlTopu45bottomFormat {}
  trait DefaultMusicxmlTopu45bottomFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Topu45bottom] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Topu45bottom] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Topu45bottom.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Topu45bottom.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Topu45bottom, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTremolou45typeFormat = new DefaultMusicxmlTremolou45typeFormat {}
  trait DefaultMusicxmlTremolou45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tremolou45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tremolou45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Tremolou45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Tremolou45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Tremolou45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTrillu45stepFormat = new DefaultMusicxmlTrillu45stepFormat {}
  trait DefaultMusicxmlTrillu45stepFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Trillu45step] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Trillu45step] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Trillu45step.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Trillu45step.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Trillu45step, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTwou45noteu45turnFormat = new DefaultMusicxmlTwou45noteu45turnFormat {}
  trait DefaultMusicxmlTwou45noteu45turnFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Twou45noteu45turn] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Twou45noteu45turn] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Twou45noteu45turn.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Twou45noteu45turn.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Twou45noteu45turn, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlUpu45downTypeFormat = new DefaultMusicxmlUpu45downTypeFormat {}
  trait DefaultMusicxmlUpu45downTypeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Upu45downType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Upu45downType] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Upu45downType.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Upu45downType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Upu45downType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlUprightu45invertedFormat = new DefaultMusicxmlUprightu45invertedFormat {}
  trait DefaultMusicxmlUprightu45invertedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Uprightu45inverted] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Uprightu45inverted] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Uprightu45inverted.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Uprightu45inverted.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Uprightu45inverted, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlValignFormat = new DefaultMusicxmlValignFormat {}
  trait DefaultMusicxmlValignFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Valign] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Valign] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Valign.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Valign.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Valign, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlValignu45imageFormat = new DefaultMusicxmlValignu45imageFormat {}
  trait DefaultMusicxmlValignu45imageFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Valignu45image] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Valignu45image] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Valignu45image.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Valignu45image.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Valignu45image, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlYesu45noFormat = new DefaultMusicxmlYesu45noFormat {}
  trait DefaultMusicxmlYesu45noFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Yesu45no] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Yesu45no] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Yesu45no.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Yesu45no.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Yesu45no, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlCancelu45locationFormat = new DefaultMusicxmlCancelu45locationFormat {}
  trait DefaultMusicxmlCancelu45locationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Cancelu45location] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Cancelu45location] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Cancelu45location.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Cancelu45location.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Cancelu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlClefu45signFormat = new DefaultMusicxmlClefu45signFormat {}
  trait DefaultMusicxmlClefu45signFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Clefu45sign] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Clefu45sign] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Clefu45sign.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Clefu45sign.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Clefu45sign, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlShowu45fretsFormat = new DefaultMusicxmlShowu45fretsFormat {}
  trait DefaultMusicxmlShowu45fretsFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Showu45frets] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Showu45frets] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Showu45frets.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Showu45frets.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Showu45frets, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStaffu45typeFormat = new DefaultMusicxmlStaffu45typeFormat {}
  trait DefaultMusicxmlStaffu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Staffu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Staffu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Staffu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Staffu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTimeu45relationFormat = new DefaultMusicxmlTimeu45relationFormat {}
  trait DefaultMusicxmlTimeu45relationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45relation] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45relation] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Timeu45relation.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Timeu45relation.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Timeu45relation, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTimeu45separatorFormat = new DefaultMusicxmlTimeu45separatorFormat {}
  trait DefaultMusicxmlTimeu45separatorFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45separator] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45separator] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Timeu45separator.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Timeu45separator.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Timeu45separator, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTimeu45symbolFormat = new DefaultMusicxmlTimeu45symbolFormat {}
  trait DefaultMusicxmlTimeu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45symbol] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Timeu45symbol.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Timeu45symbol.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Timeu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlBackwardu45forwardFormat = new DefaultMusicxmlBackwardu45forwardFormat {}
  trait DefaultMusicxmlBackwardu45forwardFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Backwardu45forward] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Backwardu45forward] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Backwardu45forward.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Backwardu45forward.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Backwardu45forward, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlBaru45styleFormat = new DefaultMusicxmlBaru45styleFormat {}
  trait DefaultMusicxmlBaru45styleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Baru45style] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Baru45style] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Baru45style.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Baru45style.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Baru45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlRightu45leftu45middleFormat = new DefaultMusicxmlRightu45leftu45middleFormat {}
  trait DefaultMusicxmlRightu45leftu45middleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Rightu45leftu45middle] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Rightu45leftu45middle] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Rightu45leftu45middle.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Rightu45leftu45middle.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Rightu45leftu45middle, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45stopu45discontinueFormat = new DefaultMusicxmlStartu45stopu45discontinueFormat {}
  trait DefaultMusicxmlStartu45stopu45discontinueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45discontinue] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45stopu45discontinue] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45stopu45discontinue.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45stopu45discontinue.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45stopu45discontinue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlWingedFormat = new DefaultMusicxmlWingedFormat {}
  trait DefaultMusicxmlWingedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Winged] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Winged] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Winged.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Winged.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Winged, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlBeateru45valueFormat = new DefaultMusicxmlBeateru45valueFormat {}
  trait DefaultMusicxmlBeateru45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Beateru45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Beateru45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Beateru45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Beateru45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Beateru45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlDegreeu45symbolu45valueFormat = new DefaultMusicxmlDegreeu45symbolu45valueFormat {}
  trait DefaultMusicxmlDegreeu45symbolu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45symbolu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Degreeu45symbolu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Degreeu45symbolu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Degreeu45symbolu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Degreeu45symbolu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlDegreeu45typeu45valueFormat = new DefaultMusicxmlDegreeu45typeu45valueFormat {}
  trait DefaultMusicxmlDegreeu45typeu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45typeu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Degreeu45typeu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Degreeu45typeu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Degreeu45typeu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Degreeu45typeu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlEffectFormat = new DefaultMusicxmlEffectFormat {}
  trait DefaultMusicxmlEffectFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Effect] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Effect] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Effect.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Effect.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Effect, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlGlassu45valueFormat = new DefaultMusicxmlGlassu45valueFormat {}
  trait DefaultMusicxmlGlassu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Glassu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Glassu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Glassu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Glassu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Glassu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHarmonyu45typeFormat = new DefaultMusicxmlHarmonyu45typeFormat {}
  trait DefaultMusicxmlHarmonyu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Harmonyu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Harmonyu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Harmonyu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Harmonyu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Harmonyu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlKindu45valueFormat = new DefaultMusicxmlKindu45valueFormat {}
  trait DefaultMusicxmlKindu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Kindu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Kindu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Kindu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Kindu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Kindu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlLineu45endFormat = new DefaultMusicxmlLineu45endFormat {}
  trait DefaultMusicxmlLineu45endFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45end] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45end] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Lineu45end.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Lineu45end.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Lineu45end, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlMeasureu45numberingu45valueFormat = new DefaultMusicxmlMeasureu45numberingu45valueFormat {}
  trait DefaultMusicxmlMeasureu45numberingu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45numberingu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Measureu45numberingu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Measureu45numberingu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Measureu45numberingu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Measureu45numberingu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlMembraneFormat = new DefaultMusicxmlMembraneFormat {}
  trait DefaultMusicxmlMembraneFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Membrane] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Membrane] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Membrane.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Membrane.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Membrane, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlMetalFormat = new DefaultMusicxmlMetalFormat {}
  trait DefaultMusicxmlMetalFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Metal] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Metal] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Metal.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Metal.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Metal, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlOnu45offFormat = new DefaultMusicxmlOnu45offFormat {}
  trait DefaultMusicxmlOnu45offFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Onu45off] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Onu45off] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Onu45off.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Onu45off.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Onu45off, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlPedalu45typeFormat = new DefaultMusicxmlPedalu45typeFormat {}
  trait DefaultMusicxmlPedalu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Pedalu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Pedalu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Pedalu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Pedalu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Pedalu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlPitchedu45valueFormat = new DefaultMusicxmlPitchedu45valueFormat {}
  trait DefaultMusicxmlPitchedu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Pitchedu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Pitchedu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Pitchedu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Pitchedu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Pitchedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlPrincipalu45voiceu45symbolFormat = new DefaultMusicxmlPrincipalu45voiceu45symbolFormat {}
  trait DefaultMusicxmlPrincipalu45voiceu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Principalu45voiceu45symbol] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Principalu45voiceu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Principalu45voiceu45symbol.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Principalu45voiceu45symbol.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Principalu45voiceu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStaffu45divideu45symbolFormat = new DefaultMusicxmlStaffu45divideu45symbolFormat {}
  trait DefaultMusicxmlStaffu45divideu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45divideu45symbol] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Staffu45divideu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Staffu45divideu45symbol.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Staffu45divideu45symbol.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Staffu45divideu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStartu45stopu45changeu45continueFormat = new DefaultMusicxmlStartu45stopu45changeu45continueFormat {}
  trait DefaultMusicxmlStartu45stopu45changeu45continueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Startu45stopu45changeu45continue] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Startu45stopu45changeu45continue] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Startu45stopu45changeu45continue.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Startu45stopu45changeu45continue.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Startu45stopu45changeu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTipu45directionFormat = new DefaultMusicxmlTipu45directionFormat {}
  trait DefaultMusicxmlTipu45directionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tipu45direction] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tipu45direction] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Tipu45direction.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Tipu45direction.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Tipu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSticku45locationFormat = new DefaultMusicxmlSticku45locationFormat {}
  trait DefaultMusicxmlSticku45locationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45location] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Sticku45location] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Sticku45location.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Sticku45location.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Sticku45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSticku45materialFormat = new DefaultMusicxmlSticku45materialFormat {}
  trait DefaultMusicxmlSticku45materialFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45material] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Sticku45material] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Sticku45material.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Sticku45material.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Sticku45material, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSticku45typeFormat = new DefaultMusicxmlSticku45typeFormat {}
  trait DefaultMusicxmlSticku45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Sticku45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Sticku45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Sticku45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Sticku45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Sticku45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlUpu45downu45stopu45continueFormat = new DefaultMusicxmlUpu45downu45stopu45continueFormat {}
  trait DefaultMusicxmlUpu45downu45stopu45continueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Upu45downu45stopu45continue] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Upu45downu45stopu45continue] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Upu45downu45stopu45continue.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Upu45downu45stopu45continue.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Upu45downu45stopu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlWedgeu45typeFormat = new DefaultMusicxmlWedgeu45typeFormat {}
  trait DefaultMusicxmlWedgeu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Wedgeu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Wedgeu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Wedgeu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Wedgeu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Wedgeu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlWoodFormat = new DefaultMusicxmlWoodFormat {}
  trait DefaultMusicxmlWoodFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Wood] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Wood] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Wood.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Wood.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Wood, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlMarginu45typeFormat = new DefaultMusicxmlMarginu45typeFormat {}
  trait DefaultMusicxmlMarginu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Marginu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Marginu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Marginu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Marginu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Marginu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlNoteu45sizeu45typeFormat = new DefaultMusicxmlNoteu45sizeu45typeFormat {}
  trait DefaultMusicxmlNoteu45sizeu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45sizeu45type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Noteu45sizeu45type] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Noteu45sizeu45type.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Noteu45sizeu45type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Noteu45sizeu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlAccidentalu45valueFormat = new DefaultMusicxmlAccidentalu45valueFormat {}
  trait DefaultMusicxmlAccidentalu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Accidentalu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Accidentalu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Accidentalu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Accidentalu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlArrowu45directionFormat = new DefaultMusicxmlArrowu45directionFormat {}
  trait DefaultMusicxmlArrowu45directionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Arrowu45direction] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Arrowu45direction] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Arrowu45direction.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Arrowu45direction.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Arrowu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlArrowu45styleFormat = new DefaultMusicxmlArrowu45styleFormat {}
  trait DefaultMusicxmlArrowu45styleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Arrowu45style] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Arrowu45style] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Arrowu45style.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Arrowu45style.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Arrowu45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlBeamu45valueFormat = new DefaultMusicxmlBeamu45valueFormat {}
  trait DefaultMusicxmlBeamu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Beamu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Beamu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Beamu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Beamu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Beamu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlBreathu45marku45valueFormat = new DefaultMusicxmlBreathu45marku45valueFormat {}
  trait DefaultMusicxmlBreathu45marku45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Breathu45marku45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Breathu45marku45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Breathu45marku45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Breathu45marku45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Breathu45marku45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlCaesurau45valueFormat = new DefaultMusicxmlCaesurau45valueFormat {}
  trait DefaultMusicxmlCaesurau45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Caesurau45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Caesurau45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Caesurau45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Caesurau45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Caesurau45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlCircularu45arrowFormat = new DefaultMusicxmlCircularu45arrowFormat {}
  trait DefaultMusicxmlCircularu45arrowFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Circularu45arrow] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Circularu45arrow] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Circularu45arrow.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Circularu45arrow.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Circularu45arrow, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlFanFormat = new DefaultMusicxmlFanFormat {}
  trait DefaultMusicxmlFanFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fan] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fan] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Fan.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Fan.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Fan, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHandbellu45valueFormat = new DefaultMusicxmlHandbellu45valueFormat {}
  trait DefaultMusicxmlHandbellu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Handbellu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Handbellu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Handbellu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Handbellu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Handbellu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHarmonu45closedu45locationFormat = new DefaultMusicxmlHarmonu45closedu45locationFormat {}
  trait DefaultMusicxmlHarmonu45closedu45locationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closedu45location] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Harmonu45closedu45location] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Harmonu45closedu45location.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Harmonu45closedu45location.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Harmonu45closedu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHarmonu45closedu45valueFormat = new DefaultMusicxmlHarmonu45closedu45valueFormat {}
  trait DefaultMusicxmlHarmonu45closedu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closedu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Harmonu45closedu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Harmonu45closedu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Harmonu45closedu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Harmonu45closedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHoleu45closedu45locationFormat = new DefaultMusicxmlHoleu45closedu45locationFormat {}
  trait DefaultMusicxmlHoleu45closedu45locationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closedu45location] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Holeu45closedu45location] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Holeu45closedu45location.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Holeu45closedu45location.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Holeu45closedu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlHoleu45closedu45valueFormat = new DefaultMusicxmlHoleu45closedu45valueFormat {}
  trait DefaultMusicxmlHoleu45closedu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closedu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Holeu45closedu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Holeu45closedu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Holeu45closedu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Holeu45closedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlNoteu45typeu45valueFormat = new DefaultMusicxmlNoteu45typeu45valueFormat {}
  trait DefaultMusicxmlNoteu45typeu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45typeu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Noteu45typeu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Noteu45typeu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Noteu45typeu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Noteu45typeu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlNoteheadu45valueFormat = new DefaultMusicxmlNoteheadu45valueFormat {}
  trait DefaultMusicxmlNoteheadu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Noteheadu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Noteheadu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Noteheadu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Noteheadu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Noteheadu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlShowu45tupletFormat = new DefaultMusicxmlShowu45tupletFormat {}
  trait DefaultMusicxmlShowu45tupletFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Showu45tuplet] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Showu45tuplet] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Showu45tuplet.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Showu45tuplet.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Showu45tuplet, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStemu45valueFormat = new DefaultMusicxmlStemu45valueFormat {}
  trait DefaultMusicxmlStemu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Stemu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Stemu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Stemu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Stemu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Stemu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlStepFormat = new DefaultMusicxmlStepFormat {}
  trait DefaultMusicxmlStepFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Step] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Step] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Step.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Step.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Step, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlSyllabicFormat = new DefaultMusicxmlSyllabicFormat {}
  trait DefaultMusicxmlSyllabicFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Syllabic] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Syllabic] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Syllabic.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Syllabic.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Syllabic, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlTapu45handFormat = new DefaultMusicxmlTapu45handFormat {}
  trait DefaultMusicxmlTapu45handFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tapu45hand] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tapu45hand] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Tapu45hand.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Tapu45hand.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Tapu45hand, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlGroupu45barlineu45valueFormat = new DefaultMusicxmlGroupu45barlineu45valueFormat {}
  trait DefaultMusicxmlGroupu45barlineu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45barlineu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45barlineu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Groupu45barlineu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Groupu45barlineu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Groupu45barlineu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMusicxmlGroupu45symbolu45valueFormat = new DefaultMusicxmlGroupu45symbolu45valueFormat {}
  trait DefaultMusicxmlGroupu45symbolu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45symbolu45value] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45symbolu45value] = seq match {
      case elem: scala.xml.Elem => Right(com.fdilke.musicxml.Groupu45symbolu45value.fromString(elem.text, elem.scope))
      case _ => Right(com.fdilke.musicxml.Groupu45symbolu45value.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.fdilke.musicxml.Groupu45symbolu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMusicxmlAccidentalu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Accidentalu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Accidentalu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Accidentalu45text(scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Accidentalu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Accidentalu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlCodaFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Coda] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Coda] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Coda] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Coda((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Coda, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Coda, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlDynamicsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Dynamics] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("dynamics")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Dynamics] =
      phrase(rep(((scalaxb.ElemName(None, "p")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ppppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pppppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "f")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ffffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfpp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rfz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sffz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "n")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfzp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Dynamics(p1.toSeq,
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@enclosure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Dynamics, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
      __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
      __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Dynamics, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.dynamicsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.DynamicsOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlEmptyFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Empty] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Empty] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Empty] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Empty())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Empty, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45placementableFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placementable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45placementable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("heel-toe")) => Right(scalaxb.fromXML[com.fdilke.musicxml.Heelu45toe](node, stack))
          case (None, Some("strong-accent")) => Right(scalaxb.fromXML[com.fdilke.musicxml.Strongu45accent](node, stack))
          case _ => Right(scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placement](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: com.fdilke.musicxml.Emptyu45placementable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: com.fdilke.musicxml.Heelu45toe => scalaxb.toXML[com.fdilke.musicxml.Heelu45toe](x, __namespace, __elementLabel, __scope, true)
      case x: com.fdilke.musicxml.Strongu45accent => scalaxb.toXML[com.fdilke.musicxml.Strongu45accent](x, __namespace, __elementLabel, __scope, true)
      case x: com.fdilke.musicxml.Emptyu45placement => scalaxb.toXML[com.fdilke.musicxml.Emptyu45placement](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultMusicxmlEmptyu45placementFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placement] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45placement] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45placement] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45placement((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45placement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45placement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45placementu45smuflFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45placementu45smufl] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45placementu45smufl] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45placementu45smufl] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45placementu45smufl((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45placementu45smufl, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45placementu45smufl, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45printu45styleFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45style] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45printu45style] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45printu45style] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45printu45style((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45printu45style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45printu45style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45printu45styleu45alignFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45styleu45align] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45printu45styleu45align] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45printu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45printu45styleu45align((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45printu45styleu45align, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45printu45styleu45align, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45printu45styleu45alignu45idFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45printu45objectu45styleu45alignFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align((node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEmptyu45trillu45soundableFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45trillu45soundable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45trillu45soundable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("mordent")) => Right(scalaxb.fromXML[com.fdilke.musicxml.Mordent](node, stack))
          case _ => Right(scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45sound](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: com.fdilke.musicxml.Emptyu45trillu45soundable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: com.fdilke.musicxml.Mordent => scalaxb.toXML[com.fdilke.musicxml.Mordent](x, __namespace, __elementLabel, __scope, true)
      case x: com.fdilke.musicxml.Emptyu45trillu45sound => scalaxb.toXML[com.fdilke.musicxml.Emptyu45trillu45sound](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultMusicxmlEmptyu45trillu45soundFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45trillu45sound] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45trillu45sound] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45trillu45sound] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45trillu45sound((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@start-note").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@trill-step").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@two-note-turn").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45trillu45sound, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
      __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
      __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45trillu45sound, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlHorizontalu45turnFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Horizontalu45turn] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Horizontalu45turn] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Horizontalu45turn] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Horizontalu45turn((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@start-note").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@trill-step").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@two-note-turn").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@slash").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Horizontalu45turn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
      __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
      __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      __obj.slash foreach { x => attr = scala.xml.Attribute(null, "slash", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Horizontalu45turn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlFermataFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fermata] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Fermata] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fermata] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Fermata(scalaxb.fromXML[com.fdilke.musicxml.Fermatau45shape](node, scalaxb.ElemName(node) :: stack),
        (node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Uprightu45inverted](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Fermata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Fermata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFingeringFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fingering] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Fingering] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fingering] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Fingering(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@substitution").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@alternate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Fingering, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.substitution foreach { x => attr = scala.xml.Attribute(null, "substitution", x.toString, attr) }
      __obj.alternate foreach { x => attr = scala.xml.Attribute(null, "alternate", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Fingering, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFormattedu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45symbol] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Formattedu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Formattedu45symbol] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Formattedu45symbol(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Formattedu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Formattedu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFormattedu45symbolu45idFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45symbolu45id] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Formattedu45symbolu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Formattedu45symbolu45id] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Formattedu45symbolu45id(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Formattedu45symbolu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Formattedu45symbolu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFormattedu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Formattedu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Formattedu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Formattedu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Formattedu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Formattedu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFormattedu45textu45idFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Formattedu45textu45id] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Formattedu45textu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Formattedu45textu45id] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Formattedu45textu45id(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Formattedu45textu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Formattedu45textu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFretFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fret] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Fret] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fret] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Fret(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Fret, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Fret, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlLevelFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Level] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Level] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Level] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Level(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@reference").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Level, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.reference foreach { x => attr = scala.xml.Attribute(null, "reference", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Level, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMidiu45deviceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Midiu45device] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Midiu45device] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Midiu45device] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Midiu45device(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@port").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Midiu45device, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.port foreach { x => attr = scala.xml.Attribute(null, "port", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Midiu45device, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMidiu45instrumentFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Midiu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("midi-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Midiu45instrument] =
      phrase(opt(scalaxb.ElemName(None, "midi-channel")) ~ 
      opt(scalaxb.ElemName(None, "midi-name")) ~ 
      opt(scalaxb.ElemName(None, "midi-bank")) ~ 
      opt(scalaxb.ElemName(None, "midi-program")) ~ 
      opt(scalaxb.ElemName(None, "midi-unpitched")) ~ 
      opt(scalaxb.ElemName(None, "volume")) ~ 
      opt(scalaxb.ElemName(None, "pan")) ~ 
      opt(scalaxb.ElemName(None, "elevation")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      com.fdilke.musicxml.Midiu45instrument(p1.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Midiu45instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Midiu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.midiu45channel map { scalaxb.toXML[BigInt](_, None, Some("midi-channel"), __scope, false) } getOrElse {Nil},
        __obj.midiu45name map { scalaxb.toXML[String](_, None, Some("midi-name"), __scope, false) } getOrElse {Nil},
        __obj.midiu45bank map { scalaxb.toXML[BigInt](_, None, Some("midi-bank"), __scope, false) } getOrElse {Nil},
        __obj.midiu45program map { scalaxb.toXML[BigInt](_, None, Some("midi-program"), __scope, false) } getOrElse {Nil},
        __obj.midiu45unpitched map { scalaxb.toXML[BigInt](_, None, Some("midi-unpitched"), __scope, false) } getOrElse {Nil},
        __obj.volume map { scalaxb.toXML[BigDecimal](_, None, Some("volume"), __scope, false) } getOrElse {Nil},
        __obj.pan map { scalaxb.toXML[BigDecimal](_, None, Some("pan"), __scope, false) } getOrElse {Nil},
        __obj.elevation map { scalaxb.toXML[BigDecimal](_, None, Some("elevation"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlNameu45displayFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Nameu45display] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("name-display")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Nameu45display] =
      phrase(rep(((scalaxb.ElemName(None, "display-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Nameu45display(p1.toSeq,
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Nameu45display, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Nameu45display, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.nameu45displayoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Nameu45displayOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlOtheru45playFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45play] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45play] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45play] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45play(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45play, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45play, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPlayFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Play] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("play")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Play] =
      phrase(rep(((scalaxb.ElemName(None, "ipa")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "semi-pitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-play")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45play](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Play(p1.toSeq,
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Play, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Play, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.playoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlSegnoFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Segno] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Segno] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Segno] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Segno((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Segno, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Segno, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlStringTypeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.StringType] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.StringType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.StringType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.StringType(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.StringType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.StringType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTypedu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Typedu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Typedu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Typedu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Typedu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Typedu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Typedu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlWavyu45lineFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Wavyu45line] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Wavyu45line] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Wavyu45line] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Wavyu45line(scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45continue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@start-note").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@trill-step").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@two-note-turn").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Wavyu45line, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
      __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
      __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Wavyu45line, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlDirectiveFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Directive] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Directive] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Directive] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Directive(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Directive, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Directive, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlAttributesTypeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.AttributesType] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("attributes")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.AttributesType] =
      phrase((parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "divisions")) ~ 
      rep(scalaxb.ElemName(None, "key")) ~ 
      rep(scalaxb.ElemName(None, "time")) ~ 
      opt(scalaxb.ElemName(None, "staves")) ~ 
      opt(scalaxb.ElemName(None, "part-symbol")) ~ 
      opt(scalaxb.ElemName(None, "instruments")) ~ 
      rep(scalaxb.ElemName(None, "clef")) ~ 
      rep(scalaxb.ElemName(None, "staff-details")) ~ 
      rep(scalaxb.ElemName(None, "transpose")) ~ 
      rep(scalaxb.ElemName(None, "directive")) ~ 
      rep(scalaxb.ElemName(None, "measure-style")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      com.fdilke.musicxml.AttributesType(p1,
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Key](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Time](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Partu45symbol](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p8.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Clef](_, scalaxb.ElemName(node) :: stack) },
        p9.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Staffu45details](_, scalaxb.ElemName(node) :: stack) },
        p10.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Transpose](_, scalaxb.ElemName(node) :: stack) },
        p11.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Directive](_, scalaxb.ElemName(node) :: stack) },
        p12.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Measureu45style](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.AttributesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence1, None, Some("editorialSequence1"), __scope, false),
        __obj.divisions map { scalaxb.toXML[BigDecimal](_, None, Some("divisions"), __scope, false) } getOrElse {Nil},
        __obj.key flatMap { scalaxb.toXML[com.fdilke.musicxml.Key](_, None, Some("key"), __scope, false) },
        __obj.time flatMap { scalaxb.toXML[com.fdilke.musicxml.Time](_, None, Some("time"), __scope, false) },
        __obj.staves map { scalaxb.toXML[BigInt](_, None, Some("staves"), __scope, false) } getOrElse {Nil},
        __obj.partu45symbol map { scalaxb.toXML[com.fdilke.musicxml.Partu45symbol](_, None, Some("part-symbol"), __scope, false) } getOrElse {Nil},
        __obj.instruments map { scalaxb.toXML[BigInt](_, None, Some("instruments"), __scope, false) } getOrElse {Nil},
        __obj.clef flatMap { scalaxb.toXML[com.fdilke.musicxml.Clef](_, None, Some("clef"), __scope, false) },
        __obj.staffu45details flatMap { scalaxb.toXML[com.fdilke.musicxml.Staffu45details](_, None, Some("staff-details"), __scope, false) },
        __obj.transpose flatMap { scalaxb.toXML[com.fdilke.musicxml.Transpose](_, None, Some("transpose"), __scope, false) },
        __obj.directive flatMap { scalaxb.toXML[com.fdilke.musicxml.Directive](_, None, Some("directive"), __scope, false) },
        __obj.measureu45style flatMap { scalaxb.toXML[com.fdilke.musicxml.Measureu45style](_, None, Some("measure-style"), __scope, false) })

  }

  trait DefaultMusicxmlBeatu45repeatFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Beatu45repeat] with MusicxmlSlashGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("beat-repeat")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Beatu45repeat] =
      phrase(opt(parseSlashGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Beatu45repeat(p1,
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@slashes").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@use-dots").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Beatu45repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.slashes foreach { x => attr = scala.xml.Attribute(null, "slashes", x.toString, attr) }
      __obj.useu45dots foreach { x => attr = scala.xml.Attribute(null, "use-dots", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Beatu45repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slashSequence1 map { scalaxb.toXML[com.fdilke.musicxml.SlashSequence](_, None, Some("slashSequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlCancelFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Cancel] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Cancel] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Cancel] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Cancel(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Cancelu45location](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Cancel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Cancel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlClefFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Clef] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("clef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Clef] =
      phrase((scalaxb.ElemName(None, "sign")) ~ 
      opt(scalaxb.ElemName(None, "line")) ~ 
      opt(scalaxb.ElemName(None, "clef-octave-change")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Clef(scalaxb.fromXML[com.fdilke.musicxml.Clefu45sign](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@additional").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@after-barline").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Clef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.additional foreach { x => attr = scala.xml.Attribute(null, "additional", x.toString, attr) }
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      __obj.afteru45barline foreach { x => attr = scala.xml.Attribute(null, "after-barline", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Clef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Clefu45sign](__obj.sign, None, Some("sign"), __scope, false),
        __obj.line map { scalaxb.toXML[BigInt](_, None, Some("line"), __scope, false) } getOrElse {Nil},
        __obj.clefu45octaveu45change map { scalaxb.toXML[BigInt](_, None, Some("clef-octave-change"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlInterchangeableFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Interchangeable] with MusicxmlTimeu45signatureGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("interchangeable")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Interchangeable] =
      phrase(opt(scalaxb.ElemName(None, "time-relation")) ~ 
      rep(parseTimeu45signatureGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Interchangeable(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45relation](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq,
        (node \ "@symbol").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45symbol](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@separator").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45separator](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Interchangeable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
      __obj.separator foreach { x => attr = scala.xml.Attribute(null, "separator", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Interchangeable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.timeu45relation map { scalaxb.toXML[com.fdilke.musicxml.Timeu45relation](_, None, Some("time-relation"), __scope, false) } getOrElse {Nil},
        __obj.timeu45signatureSequence2 flatMap { scalaxb.toXML[com.fdilke.musicxml.Timeu45signatureSequence](_, None, Some("timeu45signatureSequence2"), __scope, false) })

  }

  trait DefaultMusicxmlKeyFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Key] with MusicxmlTraditionalu45keyGroupFormat with MusicxmlNonu45traditionalu45keyGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("key")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Key] =
      phrase(rep((parseTraditionalu45keyGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      (parseNonu45traditionalu45keyGroup(node, scalaxb.ElemName(node) :: stack, true))) ~ 
      rep(scalaxb.ElemName(None, "key-octave")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Key(p1.toSeq,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Keyu45octave](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Key, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Key, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.keyoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) },
        __obj.keyu45octave flatMap { scalaxb.toXML[com.fdilke.musicxml.Keyu45octave](_, None, Some("key-octave"), __scope, false) })

  }

  trait DefaultMusicxmlKeyu45accidentalFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Keyu45accidental] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Keyu45accidental] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Keyu45accidental] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Keyu45accidental(scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Keyu45accidental, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Keyu45accidental, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlKeyu45octaveFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Keyu45octave] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Keyu45octave] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Keyu45octave] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Keyu45octave(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt]((node \ "@number"), scalaxb.ElemName(node) :: stack),
        (node \ "@cancel").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Keyu45octave, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.cancel foreach { x => attr = scala.xml.Attribute(null, "cancel", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Keyu45octave, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMeasureu45repeatFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45repeat] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Measureu45repeat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Measureu45repeat] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Measureu45repeat(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@slashes").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Measureu45repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.slashes foreach { x => attr = scala.xml.Attribute(null, "slashes", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Measureu45repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMeasureu45styleFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Measureu45style] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("measure-style")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Measureu45style] =
      phrase((((scalaxb.ElemName(None, "multiple-rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Multipleu45rest](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "measure-repeat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Measureu45repeat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "beat-repeat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Beatu45repeat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slash")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Slash](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Measureu45style(p1,
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Measureu45style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Measureu45style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (Some(__obj.measureu45styleoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Measureu45styleOption]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlMultipleu45restFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Multipleu45rest] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Multipleu45rest] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Multipleu45rest] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Multipleu45rest(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@use-symbols").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Multipleu45rest, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.useu45symbols foreach { x => attr = scala.xml.Attribute(null, "use-symbols", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Multipleu45rest, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPartu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Partu45symbol] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Partu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Partu45symbol] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Partu45symbol(scalaxb.fromXML[com.fdilke.musicxml.Groupu45symbolu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@top-staff").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bottom-staff").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Partu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.topu45staff foreach { x => attr = scala.xml.Attribute(null, "top-staff", x.toString, attr) }
      __obj.bottomu45staff foreach { x => attr = scala.xml.Attribute(null, "bottom-staff", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Partu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlSlashFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Slash] with MusicxmlSlashGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("slash")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Slash] =
      phrase(opt(parseSlashGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Slash(p1,
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@use-dots").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@use-stems").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Slash, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.useu45dots foreach { x => attr = scala.xml.Attribute(null, "use-dots", x.toString, attr) }
      __obj.useu45stems foreach { x => attr = scala.xml.Attribute(null, "use-stems", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Slash, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slashSequence1 map { scalaxb.toXML[com.fdilke.musicxml.SlashSequence](_, None, Some("slashSequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlStaffu45detailsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Staffu45details] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-details")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Staffu45details] =
      phrase(opt(scalaxb.ElemName(None, "staff-type")) ~ 
      opt(scalaxb.ElemName(None, "staff-lines")) ~ 
      rep(scalaxb.ElemName(None, "staff-tuning")) ~ 
      opt(scalaxb.ElemName(None, "capo")) ~ 
      opt(scalaxb.ElemName(None, "staff-size")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Staffu45details(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Staffu45type](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Staffu45tuning](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@show-frets").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Showu45frets](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-spacing").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Staffu45details, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.showu45frets foreach { x => attr = scala.xml.Attribute(null, "show-frets", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Staffu45details, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.staffu45type map { scalaxb.toXML[com.fdilke.musicxml.Staffu45type](_, None, Some("staff-type"), __scope, false) } getOrElse {Nil},
        __obj.staffu45lines map { scalaxb.toXML[BigInt](_, None, Some("staff-lines"), __scope, false) } getOrElse {Nil},
        __obj.staffu45tuning flatMap { scalaxb.toXML[com.fdilke.musicxml.Staffu45tuning](_, None, Some("staff-tuning"), __scope, false) },
        __obj.capo map { scalaxb.toXML[BigInt](_, None, Some("capo"), __scope, false) } getOrElse {Nil},
        __obj.staffu45size map { scalaxb.toXML[BigDecimal](_, None, Some("staff-size"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlStaffu45tuningFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Staffu45tuning] with MusicxmlTuningGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-tuning")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Staffu45tuning] =
      phrase((parseTuningGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Staffu45tuning(p1,
        (node \ "@line").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Staffu45tuning, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.line foreach { x => attr = scala.xml.Attribute(null, "line", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Staffu45tuning, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.TuningSequence](__obj.tuningSequence1, None, Some("tuningSequence1"), __scope, false))

  }

  trait DefaultMusicxmlTimeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Time] with MusicxmlTimeu45signatureGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("time")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Time] =
      phrase((((rep(parseTimeu45signatureGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "interchangeable"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.TimeSequence1(p1.toSeq,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Interchangeable](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "senza-misura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Time(p1,
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@symbol").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45symbol](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@separator").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45separator](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Time, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
      __obj.separator foreach { x => attr = scala.xml.Attribute(null, "separator", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Time, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (Some(__obj.timeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlTimeSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.TimeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.TimeSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.TimeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.timeu45signatureSequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.Timeu45signatureSequence](_, None, Some("timeu45signatureSequence1"), __scope, false) },
        __obj.interchangeable map { scalaxb.toXML[com.fdilke.musicxml.Interchangeable](_, None, Some("interchangeable"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlTransposeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Transpose] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("transpose")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Transpose] =
      phrase(opt(scalaxb.ElemName(None, "diatonic")) ~ 
      (scalaxb.ElemName(None, "chromatic")) ~ 
      opt(scalaxb.ElemName(None, "octave-change")) ~ 
      opt(scalaxb.ElemName(None, "double")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Transpose(p1.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Transpose, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Transpose, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.diatonic map { scalaxb.toXML[BigInt](_, None, Some("diatonic"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigDecimal](__obj.chromatic, None, Some("chromatic"), __scope, false),
        __obj.octaveu45change map { scalaxb.toXML[BigInt](_, None, Some("octave-change"), __scope, false) } getOrElse {Nil},
        __obj.double map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("double"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlBaru45styleu45colorFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Baru45styleu45color] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Baru45styleu45color] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Baru45styleu45color] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Baru45styleu45color(scalaxb.fromXML[com.fdilke.musicxml.Baru45style](node, scalaxb.ElemName(node) :: stack),
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Baru45styleu45color, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Baru45styleu45color, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlBarlineFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Barline] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("barline")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Barline] =
      phrase(opt(scalaxb.ElemName(None, "bar-style")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "wavy-line")) ~ 
      opt(scalaxb.ElemName(None, "segno")) ~ 
      opt(scalaxb.ElemName(None, "coda")) ~ 
      rep(scalaxb.ElemName(None, "fermata")) ~ 
      opt(scalaxb.ElemName(None, "ending")) ~ 
      opt(scalaxb.ElemName(None, "repeat")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      com.fdilke.musicxml.Barline(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Baru45styleu45color](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Wavyu45line](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Segno](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Coda](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Fermata](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Ending](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Repeat](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Rightu45leftu45middle](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Rightu45leftu45middle](scala.xml.Text("right"), scalaxb.ElemName(node) :: stack) },
        (node \ "@segno").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@coda").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@divisions").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Barline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.location.toString != "right") attr = scala.xml.Attribute(null, "location", __obj.location.toString, attr)
      __obj.segno foreach { x => attr = scala.xml.Attribute(null, "segno", x.toString, attr) }
      __obj.coda foreach { x => attr = scala.xml.Attribute(null, "coda", x.toString, attr) }
      __obj.divisions foreach { x => attr = scala.xml.Attribute(null, "divisions", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Barline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baru45style map { scalaxb.toXML[com.fdilke.musicxml.Baru45styleu45color](_, None, Some("bar-style"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence2, None, Some("editorialSequence2"), __scope, false),
        __obj.wavyu45line map { scalaxb.toXML[com.fdilke.musicxml.Wavyu45line](_, None, Some("wavy-line"), __scope, false) } getOrElse {Nil},
        __obj.segno map { scalaxb.toXML[com.fdilke.musicxml.Segno](_, None, Some("segno"), __scope, false) } getOrElse {Nil},
        __obj.coda map { scalaxb.toXML[com.fdilke.musicxml.Coda](_, None, Some("coda"), __scope, false) } getOrElse {Nil},
        __obj.fermata flatMap { scalaxb.toXML[com.fdilke.musicxml.Fermata](_, None, Some("fermata"), __scope, false) },
        __obj.ending map { scalaxb.toXML[com.fdilke.musicxml.Ending](_, None, Some("ending"), __scope, false) } getOrElse {Nil},
        __obj.repeat map { scalaxb.toXML[com.fdilke.musicxml.Repeat](_, None, Some("repeat"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlEndingFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Ending] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Ending] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Ending] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Ending(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@number"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45discontinue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@end-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@text-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@text-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Ending, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.endu45length foreach { x => attr = scala.xml.Attribute(null, "end-length", x.toString, attr) }
      __obj.textu45x foreach { x => attr = scala.xml.Attribute(null, "text-x", x.toString, attr) }
      __obj.textu45y foreach { x => attr = scala.xml.Attribute(null, "text-y", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Ending, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlRepeatFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Repeat] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Repeat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Repeat] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Repeat(scalaxb.fromXML[com.fdilke.musicxml.Backwardu45forward]((node \ "@direction"), scalaxb.ElemName(node) :: stack),
        (node \ "@times").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@winged").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Winged](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "direction", __obj.direction.toString, attr)
      __obj.times foreach { x => attr = scala.xml.Attribute(null, "times", x.toString, attr) }
      __obj.winged foreach { x => attr = scala.xml.Attribute(null, "winged", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlAccordFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Accord] with MusicxmlTuningGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("accord")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Accord] =
      phrase((parseTuningGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Accord(p1,
        (node \ "@string").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Accord, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.string foreach { x => attr = scala.xml.Attribute(null, "string", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Accord, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.TuningSequence](__obj.tuningSequence1, None, Some("tuningSequence1"), __scope, false))

  }

  trait DefaultMusicxmlAccordionu45registrationFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Accordionu45registration] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("accordion-registration")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Accordionu45registration] =
      phrase(opt(scalaxb.ElemName(None, "accordion-high")) ~ 
      opt(scalaxb.ElemName(None, "accordion-middle")) ~ 
      opt(scalaxb.ElemName(None, "accordion-low")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Accordionu45registration(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Accordionu45registration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Accordionu45registration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.accordionu45high map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("accordion-high"), __scope, false) } getOrElse {Nil},
        __obj.accordionu45middle map { scalaxb.toXML[BigInt](_, None, Some("accordion-middle"), __scope, false) } getOrElse {Nil},
        __obj.accordionu45low map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("accordion-low"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlBarreFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Barre] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Barre] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Barre] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Barre(scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Barre, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Barre, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlBassFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Bass] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("bass")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Bass] =
      phrase((scalaxb.ElemName(None, "bass-step")) ~ 
      opt(scalaxb.ElemName(None, "bass-alter")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Bass(scalaxb.fromXML[com.fdilke.musicxml.Bassu45step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Bassu45alter](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Bass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Bassu45step](__obj.bassu45step, None, Some("bass-step"), __scope, false),
        __obj.bassu45alter map { scalaxb.toXML[com.fdilke.musicxml.Bassu45alter](_, None, Some("bass-alter"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlBassu45alterFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Bassu45alter] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Bassu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bassu45alter] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bassu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Bassu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Bassu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlBassu45stepFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Bassu45step] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Bassu45step] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bassu45step] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bassu45step(scalaxb.fromXML[com.fdilke.musicxml.Step](node, scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Bassu45step, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Bassu45step, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlBeaterFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Beater] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Beater] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Beater] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Beater(scalaxb.fromXML[com.fdilke.musicxml.Beateru45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@tip").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tipu45direction](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Beater, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.tip foreach { x => attr = scala.xml.Attribute(null, "tip", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Beater, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlBeatu45unitu45tiedFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Beatu45unitu45tied] with MusicxmlBeatu45unitGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("beat-unit-tied")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Beatu45unitu45tied] =
      phrase((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Beatu45unitu45tied(p1) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Beatu45unitu45tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false))

  }

  trait DefaultMusicxmlBracketFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Bracket] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Bracket] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bracket] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bracket(scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45continue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Lineu45end]((node \ "@line-end"), scalaxb.ElemName(node) :: stack),
        (node \ "@end-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Bracket, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      attr = scala.xml.Attribute(null, "line-end", __obj.lineu45end.toString, attr)
      __obj.endu45length foreach { x => attr = scala.xml.Attribute(null, "end-length", x.toString, attr) }
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Bracket, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlDashesFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Dashes] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Dashes] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Dashes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Dashes(scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45continue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Dashes, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Dashes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlDegreeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Degree] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("degree")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Degree] =
      phrase((scalaxb.ElemName(None, "degree-value")) ~ 
      (scalaxb.ElemName(None, "degree-alter")) ~ 
      (scalaxb.ElemName(None, "degree-type")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Degree(scalaxb.fromXML[com.fdilke.musicxml.Degreeu45value](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Degreeu45alter](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Degreeu45type](p3, scalaxb.ElemName(node) :: stack),
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Degree, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Degree, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Degreeu45value](__obj.degreeu45value, None, Some("degree-value"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Degreeu45alter](__obj.degreeu45alter, None, Some("degree-alter"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Degreeu45type](__obj.degreeu45type, None, Some("degree-type"), __scope, false))

  }

  trait DefaultMusicxmlDegreeu45alterFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45alter] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Degreeu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Degreeu45alter] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Degreeu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@plus-minus").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Degreeu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.plusu45minus foreach { x => attr = scala.xml.Attribute(null, "plus-minus", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Degreeu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlDegreeu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45type] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Degreeu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Degreeu45type] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Degreeu45type(scalaxb.fromXML[com.fdilke.musicxml.Degreeu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Degreeu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Degreeu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlDegreeu45valueFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Degreeu45value] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Degreeu45value] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Degreeu45value] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Degreeu45value(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@symbol").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Degreeu45symbolu45value](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Degreeu45value, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Degreeu45value, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlDirectionFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Direction] with MusicxmlEditorialu45voiceu45directionGroupFormat with MusicxmlStaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("direction")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Direction] =
      phrase(rep(scalaxb.ElemName(None, "direction-type")) ~ 
      opt(scalaxb.ElemName(None, "offset")) ~ 
      (parseEditorialu45voiceu45directionGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "sound")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Direction(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Directionu45type](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Sound](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@directive").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.directive foreach { x => attr = scala.xml.Attribute(null, "directive", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.directionu45type flatMap { scalaxb.toXML[com.fdilke.musicxml.Directionu45type](_, None, Some("direction-type"), __scope, false) },
        __obj.offset map { scalaxb.toXML[com.fdilke.musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Editorialu45voiceu45directionSequence](__obj.editorialu45voiceu45directionSequence3, None, Some("editorialu45voiceu45directionSequence3"), __scope, false),
        __obj.staffSequence4 map { scalaxb.toXML[com.fdilke.musicxml.StaffSequence](_, None, Some("staffSequence4"), __scope, false) } getOrElse {Nil},
        __obj.sound map { scalaxb.toXML[com.fdilke.musicxml.Sound](_, None, Some("sound"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlDirectionu45typeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Directionu45type] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("direction-type")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Directionu45type] =
      phrase(rep(((scalaxb.ElemName(None, "rehearsal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "segno")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Segno](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "coda")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Coda](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((scalaxb.ElemName(None, "words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack))))) ||| 
      ((scalaxb.ElemName(None, "wedge")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Wedge](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Dynamics](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "dashes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Dashes](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "bracket")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bracket](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "pedal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pedal](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "metronome")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Metronome](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "octave-shift")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Octaveu45shift](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "harp-pedals")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harpu45pedals](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "damp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "damp-all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "eyeglasses")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "string-mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Stringu45mute](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "scordatura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Scordatura](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "image")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Image](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "principal-voice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Principalu45voice](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "percussion")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Percussion](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "accordion-registration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Accordionu45registration](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "staff-divide")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Staffu45divide](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "other-direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45direction](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Directionu45type(p1.toSeq,
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Directionu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Directionu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.directionu45typeoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Directionu45typeOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlFeatureFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Feature] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Feature] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Feature] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Feature(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@type").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Feature, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Feature, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFirstu45fretFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Firstu45fret] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Firstu45fret] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Firstu45fret] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Firstu45fret(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Firstu45fret, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Firstu45fret, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlFrameFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Frame] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("frame")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Frame] =
      phrase((scalaxb.ElemName(None, "frame-strings")) ~ 
      (scalaxb.ElemName(None, "frame-frets")) ~ 
      opt(scalaxb.ElemName(None, "first-fret")) ~ 
      rep(scalaxb.ElemName(None, "frame-note")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Frame(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Firstu45fret](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Frameu45note](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@height").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@unplayed").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Frame, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
      __obj.unplayed foreach { x => attr = scala.xml.Attribute(null, "unplayed", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Frame, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.frameu45strings, None, Some("frame-strings"), __scope, false),
        scalaxb.toXML[BigInt](__obj.frameu45frets, None, Some("frame-frets"), __scope, false),
        __obj.firstu45fret map { scalaxb.toXML[com.fdilke.musicxml.Firstu45fret](_, None, Some("first-fret"), __scope, false) } getOrElse {Nil},
        __obj.frameu45note flatMap { scalaxb.toXML[com.fdilke.musicxml.Frameu45note](_, None, Some("frame-note"), __scope, false) })

  }

  trait DefaultMusicxmlFrameu45noteFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Frameu45note] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("frame-note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Frameu45note] =
      phrase((scalaxb.ElemName(None, "string")) ~ 
      (scalaxb.ElemName(None, "fret")) ~ 
      opt(scalaxb.ElemName(None, "fingering")) ~ 
      opt(scalaxb.ElemName(None, "barre")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Frameu45note(scalaxb.fromXML[com.fdilke.musicxml.StringType](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Fret](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fingering](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Barre](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Frameu45note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.StringType](__obj.string, None, Some("string"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Fret](__obj.fret, None, Some("fret"), __scope, false),
        __obj.fingering map { scalaxb.toXML[com.fdilke.musicxml.Fingering](_, None, Some("fingering"), __scope, false) } getOrElse {Nil},
        __obj.barre map { scalaxb.toXML[com.fdilke.musicxml.Barre](_, None, Some("barre"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlGlassFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Glass] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Glass] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Glass] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Glass(scalaxb.fromXML[com.fdilke.musicxml.Glassu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Glass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Glass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlGroupingFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Grouping] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("grouping")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Grouping] =
      phrase(rep(scalaxb.ElemName(None, "feature")) ^^
      { case p1 =>
      com.fdilke.musicxml.Grouping(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Feature](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45single]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@member-of").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Grouping, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.memberu45of foreach { x => attr = scala.xml.Attribute(null, "member-of", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Grouping, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.feature flatMap { scalaxb.toXML[com.fdilke.musicxml.Feature](_, None, Some("feature"), __scope, false) })

  }

  trait DefaultMusicxmlHarmonyFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Harmony] with MusicxmlHarmonyu45chordGroupFormat with MusicxmlEditorialGroupFormat with MusicxmlStaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmony")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Harmony] =
      phrase(rep(parseHarmonyu45chordGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "frame")) ~ 
      opt(scalaxb.ElemName(None, "offset")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Harmony(p1.toSeq,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Frame](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        p4,
        p5,
        (node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Harmonyu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-frame").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Harmony, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.printu45frame foreach { x => attr = scala.xml.Attribute(null, "print-frame", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Harmony, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.harmonyu45chordSequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.Harmonyu45chordSequence](_, None, Some("harmonyu45chordSequence1"), __scope, false) },
        __obj.frame map { scalaxb.toXML[com.fdilke.musicxml.Frame](_, None, Some("frame"), __scope, false) } getOrElse {Nil},
        __obj.offset map { scalaxb.toXML[com.fdilke.musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence4, None, Some("editorialSequence4"), __scope, false),
        __obj.staffSequence5 map { scalaxb.toXML[com.fdilke.musicxml.StaffSequence](_, None, Some("staffSequence5"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlHarpu45pedalsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Harpu45pedals] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harp-pedals")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Harpu45pedals] =
      phrase(rep(scalaxb.ElemName(None, "pedal-tuning")) ^^
      { case p1 =>
      com.fdilke.musicxml.Harpu45pedals(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Pedalu45tuning](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Harpu45pedals, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Harpu45pedals, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pedalu45tuning flatMap { scalaxb.toXML[com.fdilke.musicxml.Pedalu45tuning](_, None, Some("pedal-tuning"), __scope, false) })

  }

  trait DefaultMusicxmlImageFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Image] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Image] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Image] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Image(scalaxb.fromXML[java.net.URI]((node \ "@source"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@height").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Image, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "source", __obj.source.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Image, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlInversionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Inversion] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Inversion] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Inversion] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Inversion(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Inversion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Inversion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlKindFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Kind] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Kind] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Kind] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Kind(scalaxb.fromXML[com.fdilke.musicxml.Kindu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@use-symbols").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@stack-degrees").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses-degrees").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bracket-degrees").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Kind, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.useu45symbols foreach { x => attr = scala.xml.Attribute(null, "use-symbols", x.toString, attr) }
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.stacku45degrees foreach { x => attr = scala.xml.Attribute(null, "stack-degrees", x.toString, attr) }
      __obj.parenthesesu45degrees foreach { x => attr = scala.xml.Attribute(null, "parentheses-degrees", x.toString, attr) }
      __obj.bracketu45degrees foreach { x => attr = scala.xml.Attribute(null, "bracket-degrees", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Kind, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMeasureu45numberingFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Measureu45numbering] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Measureu45numbering] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Measureu45numbering] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Measureu45numbering(scalaxb.fromXML[com.fdilke.musicxml.Measureu45numberingu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Measureu45numbering, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Measureu45numbering, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMetronomeFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Metronome] with MusicxmlBeatu45unitGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Metronome] =
      phrase(((((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "beat-unit-tied")) ~ 
      (((scalaxb.ElemName(None, "per-minute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Peru45minute](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "beat-unit-tied"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.MetronomeSequence2(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Beatu45unitu45tied](_, scalaxb.ElemName(node) :: stack) })) }))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.MetronomeSequence1(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Beatu45unitu45tied](_, scalaxb.ElemName(node) :: stack) },
        p3)) }) ||| 
      ((opt(scalaxb.ElemName(None, "metronome-arrows")) ~ 
      rep(scalaxb.ElemName(None, "metronome-note")) ~ 
      opt(((scalaxb.ElemName(None, "metronome-relation")) ~ 
      rep(scalaxb.ElemName(None, "metronome-note"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.MetronomeSequence4(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45note](_, scalaxb.ElemName(node) :: stack) }) })) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.MetronomeSequence3(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45note](_, scalaxb.ElemName(node) :: stack) },
        p3)) })) ^^
      { case p1 =>
      com.fdilke.musicxml.Metronome(p1,
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Metronome, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Metronome, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (Some(__obj.metronomeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.MetronomeOption]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlMetronomeSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.MetronomeSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.MetronomeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false),
        __obj.beatu45unitu45tied flatMap { scalaxb.toXML[com.fdilke.musicxml.Beatu45unitu45tied](_, None, Some("beat-unit-tied"), __scope, false) },
        Some(__obj.metronomeoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.MetronomeOption2]](x, x.namespace, x.key, __scope, false)} get)


  }

  trait DefaultMusicxmlMetronomeSequence2Format extends scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.MetronomeSequence2] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.MetronomeSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false),
        __obj.beatu45unitu45tied flatMap { scalaxb.toXML[com.fdilke.musicxml.Beatu45unitu45tied](_, None, Some("beat-unit-tied"), __scope, false) })


  }

  trait DefaultMusicxmlMetronomeSequence3Format extends scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.MetronomeSequence3] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.MetronomeSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.metronomeu45arrows map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("metronome-arrows"), __scope, false) } getOrElse {Nil},
        __obj.metronomeu45note flatMap { scalaxb.toXML[com.fdilke.musicxml.Metronomeu45note](_, None, Some("metronome-note"), __scope, false) },
        __obj.metronomesequence4 map { scalaxb.toXML[com.fdilke.musicxml.MetronomeSequence4](_, None, Some("metronomesequence4"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlMetronomeSequence4Format extends scalaxb.XMLFormat[com.fdilke.musicxml.MetronomeSequence4] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.MetronomeSequence4] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.MetronomeSequence4, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[String](__obj.metronomeu45relation, None, Some("metronome-relation"), __scope, false),
        __obj.metronomeu45note flatMap { scalaxb.toXML[com.fdilke.musicxml.Metronomeu45note](_, None, Some("metronome-note"), __scope, false) })


  }

  trait DefaultMusicxmlMetronomeu45beamFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45beam] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Metronomeu45beam] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Metronomeu45beam] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Metronomeu45beam(scalaxb.fromXML[com.fdilke.musicxml.Beamu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Metronomeu45beam, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Metronomeu45beam, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMetronomeu45noteFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Metronomeu45note] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome-note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Metronomeu45note] =
      phrase((scalaxb.ElemName(None, "metronome-type")) ~ 
      rep(scalaxb.ElemName(None, "metronome-dot")) ~ 
      rep(scalaxb.ElemName(None, "metronome-beam")) ~ 
      opt(scalaxb.ElemName(None, "metronome-tied")) ~ 
      opt(scalaxb.ElemName(None, "metronome-tuplet")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Metronomeu45note(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45beam](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45tied](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45tuplet](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Metronomeu45note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Noteu45typeu45value](__obj.metronomeu45type, None, Some("metronome-type"), __scope, false),
        __obj.metronomeu45dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("metronome-dot"), __scope, false) },
        __obj.metronomeu45beam flatMap { scalaxb.toXML[com.fdilke.musicxml.Metronomeu45beam](_, None, Some("metronome-beam"), __scope, false) },
        __obj.metronomeu45tied map { scalaxb.toXML[com.fdilke.musicxml.Metronomeu45tied](_, None, Some("metronome-tied"), __scope, false) } getOrElse {Nil},
        __obj.metronomeu45tuplet map { scalaxb.toXML[com.fdilke.musicxml.Metronomeu45tuplet](_, None, Some("metronome-tuplet"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlMetronomeu45tiedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Metronomeu45tied] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Metronomeu45tied] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Metronomeu45tied] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Metronomeu45tied(scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Metronomeu45tied, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Metronomeu45tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlMetronomeu45tupletFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Metronomeu45tuplet] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome-tuplet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Metronomeu45tuplet] =
      phrase((scalaxb.ElemName(None, "actual-notes")) ~ 
      (scalaxb.ElemName(None, "normal-notes")) ~ 
      opt(((scalaxb.ElemName(None, "normal-type")) ~ 
      rep(scalaxb.ElemName(None, "normal-dot"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Timeu45modificationableSequence1(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Metronomeu45tuplet(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3,
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@show-number").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Showu45tuplet](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Metronomeu45tuplet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.showu45number foreach { x => attr = scala.xml.Attribute(null, "show-number", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Metronomeu45tuplet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.actualu45notes, None, Some("actual-notes"), __scope, false),
        scalaxb.toXML[BigInt](__obj.normalu45notes, None, Some("normal-notes"), __scope, false),
        __obj.timeu45modificationablesequence1 map { scalaxb.toXML[com.fdilke.musicxml.Timeu45modificationableSequence1](_, None, Some("timeu45modificationablesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlOctaveu45shiftFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Octaveu45shift] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Octaveu45shift] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Octaveu45shift] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Octaveu45shift(scalaxb.fromXML[com.fdilke.musicxml.Upu45downu45stopu45continue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@size").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("8"), scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Octaveu45shift, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      if (__obj.size.toString != "8") attr = scala.xml.Attribute(null, "size", __obj.size.toString, attr)
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Octaveu45shift, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlOffsetFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Offset] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Offset] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Offset] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Offset(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        (node \ "@sound").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Offset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.sound foreach { x => attr = scala.xml.Attribute(null, "sound", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Offset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlOtheru45directionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45direction] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45direction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45direction] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45direction(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPedalFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Pedal] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Pedal] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Pedal] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Pedal(scalaxb.fromXML[com.fdilke.musicxml.Pedalu45type]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@sign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@abbreviated").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Pedal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.line foreach { x => attr = scala.xml.Attribute(null, "line", x.toString, attr) }
      __obj.sign foreach { x => attr = scala.xml.Attribute(null, "sign", x.toString, attr) }
      __obj.abbreviated foreach { x => attr = scala.xml.Attribute(null, "abbreviated", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Pedal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlPedalu45tuningFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Pedalu45tuning] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("pedal-tuning")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Pedalu45tuning] =
      phrase((scalaxb.ElemName(None, "pedal-step")) ~ 
      (scalaxb.ElemName(None, "pedal-alter")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Pedalu45tuning(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Pedalu45tuning, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Step](__obj.pedalu45step, None, Some("pedal-step"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.pedalu45alter, None, Some("pedal-alter"), __scope, false))

  }

  trait DefaultMusicxmlPeru45minuteFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Peru45minute] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Peru45minute] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Peru45minute] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Peru45minute(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Peru45minute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Peru45minute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPercussionFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Percussion] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("percussion")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Percussion] =
      phrase((((scalaxb.ElemName(None, "glass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Glass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "metal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "wood")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "membrane")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "effect")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "timpani")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "beater")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Beater](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stick")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Stick](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stick-location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-percussion")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Percussion(p1,
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@enclosure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Percussion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Percussion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (Some(__obj.percussionoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlPitchedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Pitched] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Pitched] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Pitched] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Pitched(scalaxb.fromXML[com.fdilke.musicxml.Pitchedu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Pitched, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Pitched, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPrincipalu45voiceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Principalu45voice] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Principalu45voice] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Principalu45voice] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Principalu45voice(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Principalu45voiceu45symbol]((node \ "@symbol"), scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Principalu45voice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr = scala.xml.Attribute(null, "symbol", __obj.symbol.toString, attr)
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Principalu45voice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPrintFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Print] with MusicxmlLayoutGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("print")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Print] =
      phrase((parseLayoutGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "measure-layout")) ~ 
      opt(scalaxb.ElemName(None, "measure-numbering")) ~ 
      opt(scalaxb.ElemName(None, "part-name-display")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation-display")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Print(p1,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Measureu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Measureu45numbering](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@staff-spacing").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@new-system").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@new-page").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@blank-page").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@page-number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Print, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.staffu45spacing foreach { x => attr = scala.xml.Attribute(null, "staff-spacing", x.toString, attr) }
      __obj.newu45system foreach { x => attr = scala.xml.Attribute(null, "new-system", x.toString, attr) }
      __obj.newu45page foreach { x => attr = scala.xml.Attribute(null, "new-page", x.toString, attr) }
      __obj.blanku45page foreach { x => attr = scala.xml.Attribute(null, "blank-page", x.toString, attr) }
      __obj.pageu45number foreach { x => attr = scala.xml.Attribute(null, "page-number", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Print, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.LayoutSequence](__obj.layoutSequence1, None, Some("layoutSequence1"), __scope, false),
        __obj.measureu45layout map { scalaxb.toXML[com.fdilke.musicxml.Measureu45layout](_, None, Some("measure-layout"), __scope, false) } getOrElse {Nil},
        __obj.measureu45numbering map { scalaxb.toXML[com.fdilke.musicxml.Measureu45numbering](_, None, Some("measure-numbering"), __scope, false) } getOrElse {Nil},
        __obj.partu45nameu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("part-name-display"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviationu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("part-abbreviation-display"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlRootFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Root] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("root")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Root] =
      phrase((scalaxb.ElemName(None, "root-step")) ~ 
      opt(scalaxb.ElemName(None, "root-alter")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Root(scalaxb.fromXML[com.fdilke.musicxml.Rootu45step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Rootu45alter](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Root, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Rootu45step](__obj.rootu45step, None, Some("root-step"), __scope, false),
        __obj.rootu45alter map { scalaxb.toXML[com.fdilke.musicxml.Rootu45alter](_, None, Some("root-alter"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlRootu45alterFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Rootu45alter] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Rootu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Rootu45alter] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Rootu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Rootu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Rootu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlRootu45stepFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Rootu45step] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Rootu45step] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Rootu45step] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Rootu45step(scalaxb.fromXML[com.fdilke.musicxml.Step](node, scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Rootu45step, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Rootu45step, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlScordaturaFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scordatura] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("scordatura")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scordatura] =
      phrase(rep(scalaxb.ElemName(None, "accord")) ^^
      { case p1 =>
      com.fdilke.musicxml.Scordatura(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Accord](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Scordatura, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Scordatura, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accord flatMap { scalaxb.toXML[com.fdilke.musicxml.Accord](_, None, Some("accord"), __scope, false) })

  }

  trait DefaultMusicxmlSoundFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Sound] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("sound")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Sound] =
      phrase(rep((opt(scalaxb.ElemName(None, "midi-device")) ~ 
      opt(scalaxb.ElemName(None, "midi-instrument")) ~ 
      opt(scalaxb.ElemName(None, "play"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.SoundSequence1(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Midiu45device](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Midiu45instrument](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Play](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      opt(scalaxb.ElemName(None, "offset")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Sound(p1.toSeq,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@tempo").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dynamics").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dacapo").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@segno").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dalsegno").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@coda").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@tocoda").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@divisions").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@forward-repeat").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@fine").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@time-only").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@pizzicato").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@pan").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@elevation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@damper-pedal").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@soft-pedal").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@sostenuto-pedal").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Sound, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.tempo foreach { x => attr = scala.xml.Attribute(null, "tempo", x.toString, attr) }
      __obj.dynamics foreach { x => attr = scala.xml.Attribute(null, "dynamics", x.toString, attr) }
      __obj.dacapo foreach { x => attr = scala.xml.Attribute(null, "dacapo", x.toString, attr) }
      __obj.segno foreach { x => attr = scala.xml.Attribute(null, "segno", x.toString, attr) }
      __obj.dalsegno foreach { x => attr = scala.xml.Attribute(null, "dalsegno", x.toString, attr) }
      __obj.coda foreach { x => attr = scala.xml.Attribute(null, "coda", x.toString, attr) }
      __obj.tocoda foreach { x => attr = scala.xml.Attribute(null, "tocoda", x.toString, attr) }
      __obj.divisions foreach { x => attr = scala.xml.Attribute(null, "divisions", x.toString, attr) }
      __obj.forwardu45repeat foreach { x => attr = scala.xml.Attribute(null, "forward-repeat", x.toString, attr) }
      __obj.fine foreach { x => attr = scala.xml.Attribute(null, "fine", x.toString, attr) }
      __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
      __obj.pizzicato foreach { x => attr = scala.xml.Attribute(null, "pizzicato", x.toString, attr) }
      __obj.pan foreach { x => attr = scala.xml.Attribute(null, "pan", x.toString, attr) }
      __obj.elevation foreach { x => attr = scala.xml.Attribute(null, "elevation", x.toString, attr) }
      __obj.damperu45pedal foreach { x => attr = scala.xml.Attribute(null, "damper-pedal", x.toString, attr) }
      __obj.softu45pedal foreach { x => attr = scala.xml.Attribute(null, "soft-pedal", x.toString, attr) }
      __obj.sostenutou45pedal foreach { x => attr = scala.xml.Attribute(null, "sostenuto-pedal", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Sound, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.soundsequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.SoundSequence1](_, None, Some("soundsequence1"), __scope, false) },
        __obj.offset map { scalaxb.toXML[com.fdilke.musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlSoundSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.SoundSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.SoundSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.SoundSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.midiu45device map { scalaxb.toXML[com.fdilke.musicxml.Midiu45device](_, None, Some("midi-device"), __scope, false) } getOrElse {Nil},
        __obj.midiu45instrument map { scalaxb.toXML[com.fdilke.musicxml.Midiu45instrument](_, None, Some("midi-instrument"), __scope, false) } getOrElse {Nil},
        __obj.play map { scalaxb.toXML[com.fdilke.musicxml.Play](_, None, Some("play"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlStaffu45divideFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Staffu45divide] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Staffu45divide] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Staffu45divide] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Staffu45divide(scalaxb.fromXML[com.fdilke.musicxml.Staffu45divideu45symbol]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Staffu45divide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Staffu45divide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlStickFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Stick] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("stick")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Stick] =
      phrase((scalaxb.ElemName(None, "stick-type")) ~ 
      (scalaxb.ElemName(None, "stick-material")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Stick(scalaxb.fromXML[com.fdilke.musicxml.Sticku45type](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Sticku45material](p2, scalaxb.ElemName(node) :: stack),
        (node \ "@tip").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tipu45direction](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dashed-circle").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Stick, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.tip foreach { x => attr = scala.xml.Attribute(null, "tip", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.dashedu45circle foreach { x => attr = scala.xml.Attribute(null, "dashed-circle", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Stick, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Sticku45type](__obj.sticku45type, None, Some("stick-type"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Sticku45material](__obj.sticku45material, None, Some("stick-material"), __scope, false))

  }

  trait DefaultMusicxmlStringu45muteFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Stringu45mute] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Stringu45mute] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Stringu45mute] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Stringu45mute(scalaxb.fromXML[com.fdilke.musicxml.Onu45off]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Stringu45mute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Stringu45mute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlWedgeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Wedge] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Wedge] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Wedge] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Wedge(scalaxb.fromXML[com.fdilke.musicxml.Wedgeu45type]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@spread").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@niente").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Wedge, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.spread foreach { x => attr = scala.xml.Attribute(null, "spread", x.toString, attr) }
      __obj.niente foreach { x => attr = scala.xml.Attribute(null, "niente", x.toString, attr) }
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Wedge, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlEncodingFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Encoding] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("encoding")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Encoding] =
      phrase(rep(((scalaxb.ElemName(None, "encoding-date")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "encoder")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Typedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "software")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "encoding-description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "supports")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Supports](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Encoding(p1.toSeq: _*) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Encoding, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.encodingoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlIdentificationFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Identification] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("identification")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Identification] =
      phrase(rep(scalaxb.ElemName(None, "creator")) ~ 
      rep(scalaxb.ElemName(None, "rights")) ~ 
      opt(scalaxb.ElemName(None, "encoding")) ~ 
      opt(scalaxb.ElemName(None, "source")) ~ 
      rep(scalaxb.ElemName(None, "relation")) ~ 
      opt(scalaxb.ElemName(None, "miscellaneous")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      com.fdilke.musicxml.Identification(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Encoding](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Miscellaneous](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Identification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.creator flatMap { scalaxb.toXML[com.fdilke.musicxml.Typedu45text](_, None, Some("creator"), __scope, false) },
        __obj.rights flatMap { scalaxb.toXML[com.fdilke.musicxml.Typedu45text](_, None, Some("rights"), __scope, false) },
        __obj.encoding map { scalaxb.toXML[com.fdilke.musicxml.Encoding](_, None, Some("encoding"), __scope, false) } getOrElse {Nil},
        __obj.source map { scalaxb.toXML[String](_, None, Some("source"), __scope, false) } getOrElse {Nil},
        __obj.relation flatMap { scalaxb.toXML[com.fdilke.musicxml.Typedu45text](_, None, Some("relation"), __scope, false) },
        __obj.miscellaneous map { scalaxb.toXML[com.fdilke.musicxml.Miscellaneous](_, None, Some("miscellaneous"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlMiscellaneousFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Miscellaneous] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("miscellaneous")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Miscellaneous] =
      phrase(rep(scalaxb.ElemName(None, "miscellaneous-field")) ^^
      { case p1 =>
      com.fdilke.musicxml.Miscellaneous(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Miscellaneousu45field](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Miscellaneous, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.miscellaneousu45field flatMap { scalaxb.toXML[com.fdilke.musicxml.Miscellaneousu45field](_, None, Some("miscellaneous-field"), __scope, false) })

  }

  trait DefaultMusicxmlMiscellaneousu45fieldFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Miscellaneousu45field] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Miscellaneousu45field] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Miscellaneousu45field] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Miscellaneousu45field(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@name"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Miscellaneousu45field, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Miscellaneousu45field, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlSupportsFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Supports] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Supports] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Supports] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Supports(scalaxb.fromXML[com.fdilke.musicxml.Yesu45no]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@element"), scalaxb.ElemName(node) :: stack),
        (node \ "@attribute").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@value").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Supports, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr = scala.xml.Attribute(null, "element", __obj.element.toString, attr)
      __obj.attribute foreach { x => attr = scala.xml.Attribute(null, "attribute", x.toString, attr) }
      __obj.value foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Supports, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlAppearanceFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Appearance] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("appearance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Appearance] =
      phrase(rep(scalaxb.ElemName(None, "line-width")) ~ 
      rep(scalaxb.ElemName(None, "note-size")) ~ 
      rep(scalaxb.ElemName(None, "distance")) ~ 
      rep(scalaxb.ElemName(None, "glyph")) ~ 
      rep(scalaxb.ElemName(None, "other-appearance")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Appearance(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45width](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Noteu45size](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Distance](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Glyph](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Otheru45appearance](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Appearance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.lineu45width flatMap { scalaxb.toXML[com.fdilke.musicxml.Lineu45width](_, None, Some("line-width"), __scope, false) },
        __obj.noteu45size flatMap { scalaxb.toXML[com.fdilke.musicxml.Noteu45size](_, None, Some("note-size"), __scope, false) },
        __obj.distance flatMap { scalaxb.toXML[com.fdilke.musicxml.Distance](_, None, Some("distance"), __scope, false) },
        __obj.glyph flatMap { scalaxb.toXML[com.fdilke.musicxml.Glyph](_, None, Some("glyph"), __scope, false) },
        __obj.otheru45appearance flatMap { scalaxb.toXML[com.fdilke.musicxml.Otheru45appearance](_, None, Some("other-appearance"), __scope, false) })

  }

  trait DefaultMusicxmlDistanceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Distance] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Distance] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Distance] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Distance(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Distance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Distance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlGlyphFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Glyph] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Glyph] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Glyph] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Glyph(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Glyph, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Glyph, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlLineu45widthFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lineu45width] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Lineu45width] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45width] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lineu45width(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Lineu45width, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Lineu45width, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlMeasureu45layoutFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Measureu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("measure-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Measureu45layout] =
      phrase(opt(scalaxb.ElemName(None, "measure-distance")) ^^
      { case p1 =>
      com.fdilke.musicxml.Measureu45layout(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Measureu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.measureu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("measure-distance"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlNoteu45sizeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45size] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Noteu45size] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Noteu45size] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Noteu45size(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Noteu45sizeu45type]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Noteu45size, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Noteu45size, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlOtheru45appearanceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45appearance] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45appearance] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45appearance] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45appearance(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45appearance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45appearance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPageu45layoutFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Pageu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("page-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Pageu45layout] =
      phrase(opt(((scalaxb.ElemName(None, "page-height")) ~ 
      (scalaxb.ElemName(None, "page-width"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Pageu45layoutSequence1(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) }) ~ 
      rep(scalaxb.ElemName(None, "page-margins")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Pageu45layout(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Pageu45margins](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Pageu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.pageu45layoutsequence1 map { scalaxb.toXML[com.fdilke.musicxml.Pageu45layoutSequence1](_, None, Some("pageu45layoutsequence1"), __scope, false) } getOrElse {Nil},
        __obj.pageu45margins flatMap { scalaxb.toXML[com.fdilke.musicxml.Pageu45margins](_, None, Some("page-margins"), __scope, false) })

  }

  trait DefaultMusicxmlPageu45layoutSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.Pageu45layoutSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Pageu45layoutSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Pageu45layoutSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.pageu45height, None, Some("page-height"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.pageu45width, None, Some("page-width"), __scope, false))


  }

  trait DefaultMusicxmlPageu45marginsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Pageu45margins] with MusicxmlAllu45marginsGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("page-margins")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Pageu45margins] =
      phrase((parseAllu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Pageu45margins(p1,
        (node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Marginu45type](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Pageu45margins, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Pageu45margins, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.Allu45marginsSequence](__obj.allu45marginsSequence1, None, Some("allu45marginsSequence1"), __scope, false))

  }

  trait DefaultMusicxmlScalingFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scaling] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("scaling")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scaling] =
      phrase((scalaxb.ElemName(None, "millimeters")) ~ 
      (scalaxb.ElemName(None, "tenths")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Scaling(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Scaling, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.millimeters, None, Some("millimeters"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.tenths, None, Some("tenths"), __scope, false))

  }

  trait DefaultMusicxmlStaffu45layoutFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Staffu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Staffu45layout] =
      phrase(opt(scalaxb.ElemName(None, "staff-distance")) ^^
      { case p1 =>
      com.fdilke.musicxml.Staffu45layout(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Staffu45layout, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Staffu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.staffu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("staff-distance"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlSystemu45dividersFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Systemu45dividers] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-dividers")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Systemu45dividers] =
      phrase((scalaxb.ElemName(None, "left-divider")) ~ 
      (scalaxb.ElemName(None, "right-divider")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Systemu45dividers(scalaxb.fromXML[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Systemu45dividers, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align](__obj.leftu45divider, None, Some("left-divider"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Emptyu45printu45objectu45styleu45align](__obj.rightu45divider, None, Some("right-divider"), __scope, false))

  }

  trait DefaultMusicxmlSystemu45layoutFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Systemu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Systemu45layout] =
      phrase(opt(scalaxb.ElemName(None, "system-margins")) ~ 
      opt(scalaxb.ElemName(None, "system-distance")) ~ 
      opt(scalaxb.ElemName(None, "top-system-distance")) ~ 
      opt(scalaxb.ElemName(None, "system-dividers")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Systemu45layout(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Systemu45margins](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Systemu45dividers](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Systemu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.systemu45margins map { scalaxb.toXML[com.fdilke.musicxml.Systemu45margins](_, None, Some("system-margins"), __scope, false) } getOrElse {Nil},
        __obj.systemu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("system-distance"), __scope, false) } getOrElse {Nil},
        __obj.topu45systemu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("top-system-distance"), __scope, false) } getOrElse {Nil},
        __obj.systemu45dividers map { scalaxb.toXML[com.fdilke.musicxml.Systemu45dividers](_, None, Some("system-dividers"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlSystemu45marginsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Systemu45margins] with MusicxmlLeftu45rightu45marginsGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-margins")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Systemu45margins] =
      phrase((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Systemu45margins(p1) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Systemu45margins, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.Leftu45rightu45marginsSequence](__obj.leftu45rightu45marginsSequence1, None, Some("leftu45rightu45marginsSequence1"), __scope, false))

  }

  trait DefaultMusicxmlBookmarkFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Bookmark] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Bookmark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bookmark] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bookmark(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@element").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@position").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Bookmark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
      __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Bookmark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlLinkFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Link] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Link] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Link] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Link(scalaxb.fromXML[java.net.URI]((node \ "@{http://www.w3.org/1999/xlink}href"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack),
        (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Show](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Actuate](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack) },
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@element").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@position").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Link, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
      __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
      __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
      if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
      if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
      __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Link, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlAccidentalFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Accidental] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Accidental] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Accidental] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Accidental(scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@cautionary").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@editorial").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Accidental, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.cautionary foreach { x => attr = scala.xml.Attribute(null, "cautionary", x.toString, attr) }
      __obj.editorial foreach { x => attr = scala.xml.Attribute(null, "editorial", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Accidental, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlAccidentalu45markFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Accidentalu45mark] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Accidentalu45mark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Accidentalu45mark] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Accidentalu45mark(scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Accidentalu45mark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Accidentalu45mark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlArpeggiateFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Arpeggiate] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Arpeggiate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Arpeggiate] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Arpeggiate((node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@direction").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Upu45downType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Arpeggiate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Arpeggiate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlArticulationsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Articulations] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("articulations")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Articulations] =
      phrase(rep(((scalaxb.ElemName(None, "accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "strong-accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Strongu45accent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "staccato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tenuto")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "detached-legato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "staccatissimo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "spiccato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "scoop")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "plop")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "doit")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "falloff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "breath-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Breathu45mark](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "caesura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Caesura](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stress")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unstress")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "soft-accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-articulation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Articulations(p1.toSeq,
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Articulations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Articulations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.articulationsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.ArticulationsOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlArrowFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Arrow] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("arrow")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Arrow] =
      phrase(((((scalaxb.ElemName(None, "arrow-direction")) ~ 
      opt(scalaxb.ElemName(None, "arrow-style")) ~ 
      opt(scalaxb.ElemName(None, "arrowhead"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.ArrowSequence1(scalaxb.fromXML[com.fdilke.musicxml.Arrowu45direction](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Arrowu45style](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "circular-arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Arrow(p1,
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Arrow, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Arrow, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (Some(__obj.arrowoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlArrowSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.ArrowSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.ArrowSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.ArrowSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Arrowu45direction](__obj.arrowu45direction, None, Some("arrow-direction"), __scope, false),
        __obj.arrowu45style map { scalaxb.toXML[com.fdilke.musicxml.Arrowu45style](_, None, Some("arrow-style"), __scope, false) } getOrElse {Nil},
        __obj.arrowhead map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("arrowhead"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlBackupFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Backup] with MusicxmlDurationGroupFormat with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("backup")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Backup] =
      phrase((parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Backup(p1,
        p2) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Backup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.DurationSequence](__obj.durationSequence1, None, Some("durationSequence1"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence2, None, Some("editorialSequence2"), __scope, false))

  }

  trait DefaultMusicxmlBeamFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Beam] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Beam] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Beam] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Beam(scalaxb.fromXML[com.fdilke.musicxml.Beamu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@repeater").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@fan").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fan](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Beam, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.repeater foreach { x => attr = scala.xml.Attribute(null, "repeater", x.toString, attr) }
      __obj.fan foreach { x => attr = scala.xml.Attribute(null, "fan", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Beam, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlBendFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Bend] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("bend")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Bend] =
      phrase((scalaxb.ElemName(None, "bend-alter")) ~ 
      opt(((scalaxb.ElemName(None, "pre-bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "release")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "with-bar")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Bend(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        p2,
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Placementu45text](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@first-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Bend, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Bend, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.bendu45alter, None, Some("bend-alter"), __scope, false),
        __obj.bendoption map { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.BendOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.withu45bar map { scalaxb.toXML[com.fdilke.musicxml.Placementu45text](_, None, Some("with-bar"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlBreathu45markFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Breathu45mark] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Breathu45mark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Breathu45mark] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Breathu45mark(scalaxb.fromXML[com.fdilke.musicxml.Breathu45marku45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Breathu45mark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Breathu45mark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlCaesuraFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Caesura] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Caesura] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Caesura] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Caesura(scalaxb.fromXML[com.fdilke.musicxml.Caesurau45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Caesura, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Caesura, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlElisionFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Elision] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Elision] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Elision] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Elision(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Elision, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Elision, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlEmptyu45lineFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45line] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45line] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45line] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45line((node \ "@line-shape").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45shape](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-length").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45length](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45line, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.lineu45length foreach { x => attr = scala.xml.Attribute(null, "line-length", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45line, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlExtendFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Extend] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Extend] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Extend] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Extend((node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45continue](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Extend, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Extend, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlFigureFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Figure] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("figure")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Figure] =
      phrase(opt(scalaxb.ElemName(None, "prefix")) ~ 
      opt(scalaxb.ElemName(None, "figure-number")) ~ 
      opt(scalaxb.ElemName(None, "suffix")) ~ 
      opt(scalaxb.ElemName(None, "extend")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Figure(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Extend](_, scalaxb.ElemName(node) :: stack) },
        p5) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Figure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.prefix map { scalaxb.toXML[com.fdilke.musicxml.Styleu45text](_, None, Some("prefix"), __scope, false) } getOrElse {Nil},
        __obj.figureu45number map { scalaxb.toXML[com.fdilke.musicxml.Styleu45text](_, None, Some("figure-number"), __scope, false) } getOrElse {Nil},
        __obj.suffix map { scalaxb.toXML[com.fdilke.musicxml.Styleu45text](_, None, Some("suffix"), __scope, false) } getOrElse {Nil},
        __obj.extend map { scalaxb.toXML[com.fdilke.musicxml.Extend](_, None, Some("extend"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence5, None, Some("editorialSequence5"), __scope, false))

  }

  trait DefaultMusicxmlFiguredu45bassFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Figuredu45bass] with MusicxmlDurationGroupFormat with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("figured-bass")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Figuredu45bass] =
      phrase(rep(scalaxb.ElemName(None, "figure")) ~ 
      opt(parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Figuredu45bass(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Figure](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-dot").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-spacing").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-lyric").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Figuredu45bass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
      __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
      __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Figuredu45bass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.figure flatMap { scalaxb.toXML[com.fdilke.musicxml.Figure](_, None, Some("figure"), __scope, false) },
        __obj.durationSequence2 map { scalaxb.toXML[com.fdilke.musicxml.DurationSequence](_, None, Some("durationSequence2"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence3, None, Some("editorialSequence3"), __scope, false))

  }

  trait DefaultMusicxmlForwardFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Forward] with MusicxmlDurationGroupFormat with MusicxmlEditorialu45voiceGroupFormat with MusicxmlStaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("forward")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Forward] =
      phrase((parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialu45voiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Forward(p1,
        p2,
        p3) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Forward, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.DurationSequence](__obj.durationSequence1, None, Some("durationSequence1"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Editorialu45voiceSequence](__obj.editorialu45voiceSequence2, None, Some("editorialu45voiceSequence2"), __scope, false),
        __obj.staffSequence3 map { scalaxb.toXML[com.fdilke.musicxml.StaffSequence](_, None, Some("staffSequence3"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlGlissandoFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Glissando] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Glissando] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Glissando] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Glissando(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Glissando, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Glissando, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlGraceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Grace] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Grace] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Grace] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Grace((node \ "@steal-time-previous").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@steal-time-following").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@make-time").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@slash").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Grace, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.stealu45timeu45previous foreach { x => attr = scala.xml.Attribute(null, "steal-time-previous", x.toString, attr) }
      __obj.stealu45timeu45following foreach { x => attr = scala.xml.Attribute(null, "steal-time-following", x.toString, attr) }
      __obj.makeu45time foreach { x => attr = scala.xml.Attribute(null, "make-time", x.toString, attr) }
      __obj.slash foreach { x => attr = scala.xml.Attribute(null, "slash", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Grace, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlHammeru45onu45pullu45offFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Hammeru45onu45pullu45off] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Hammeru45onu45pullu45off] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Hammeru45onu45pullu45off] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Hammeru45onu45pullu45off(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Hammeru45onu45pullu45off, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Hammeru45onu45pullu45off, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlHandbellFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Handbell] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Handbell] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Handbell] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Handbell(scalaxb.fromXML[com.fdilke.musicxml.Handbellu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Handbell, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Handbell, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlHarmonu45closedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Harmonu45closed] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Harmonu45closed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Harmonu45closed] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Harmonu45closed(scalaxb.fromXML[com.fdilke.musicxml.Harmonu45closedu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Harmonu45closedu45location](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Harmonu45closed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Harmonu45closed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlHarmonu45muteFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Harmonu45mute] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmon-mute")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Harmonu45mute] =
      phrase((scalaxb.ElemName(None, "harmon-closed")) ^^
      { case p1 =>
      com.fdilke.musicxml.Harmonu45mute(scalaxb.fromXML[com.fdilke.musicxml.Harmonu45closed](p1, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Harmonu45mute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Harmonu45mute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[com.fdilke.musicxml.Harmonu45closed](__obj.harmonu45closed, None, Some("harmon-closed"), __scope, false))

  }

  trait DefaultMusicxmlHarmonicFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Harmonic] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmonic")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Harmonic] =
      phrase(opt(((scalaxb.ElemName(None, "natural")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "artificial")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(((scalaxb.ElemName(None, "base-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "touching-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sounding-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Harmonic(p1,
        p2,
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Harmonic, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Harmonic, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.harmonicoption map { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.HarmonicOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.harmonicoption2 map { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.HarmonicOption2]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlHeelu45toeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Heelu45toe] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Heelu45toe] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Heelu45toe] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Heelu45toe((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@substitution").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Heelu45toe, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.substitution foreach { x => attr = scala.xml.Attribute(null, "substitution", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Heelu45toe, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlHoleFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Hole] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("hole")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Hole] =
      phrase(opt(scalaxb.ElemName(None, "hole-type")) ~ 
      (scalaxb.ElemName(None, "hole-closed")) ~ 
      opt(scalaxb.ElemName(None, "hole-shape")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Hole(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Holeu45closed](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Hole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Hole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.holeu45type map { scalaxb.toXML[String](_, None, Some("hole-type"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Holeu45closed](__obj.holeu45closed, None, Some("hole-closed"), __scope, false),
        __obj.holeu45shape map { scalaxb.toXML[String](_, None, Some("hole-shape"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlHoleu45closedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Holeu45closed] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Holeu45closed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Holeu45closed] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Holeu45closed(scalaxb.fromXML[com.fdilke.musicxml.Holeu45closedu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@location").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Holeu45closedu45location](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Holeu45closed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Holeu45closed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlInstrumentFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Instrument] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Instrument] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Instrument] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Instrument(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlLyricFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Lyric] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("lyric")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Lyric] =
      phrase((((opt(scalaxb.ElemName(None, "syllabic")) ~ 
      (scalaxb.ElemName(None, "text")) ~ 
      rep((opt(((scalaxb.ElemName(None, "elision")) ~ 
      opt(scalaxb.ElemName(None, "syllabic"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.LyricSequence3(scalaxb.fromXML[com.fdilke.musicxml.Elision](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Syllabic](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      (scalaxb.ElemName(None, "text"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.LyricSequence2(p1,
        scalaxb.fromXML[com.fdilke.musicxml.Textu45elementu45data](p2, scalaxb.ElemName(node) :: stack)) }) ~ 
      opt(scalaxb.ElemName(None, "extend"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => scalaxb.DataRecord(com.fdilke.musicxml.LyricSequence1(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Syllabic](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Textu45elementu45data](p2, scalaxb.ElemName(node) :: stack),
        p3.toSeq,
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Extend](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "extend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Extend](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "laughing")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "humming")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "end-line")) ~ 
      opt(scalaxb.ElemName(None, "end-paragraph")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Lyric(p1,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p4,
        (node \ "@number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@time-only").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Lyric, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Lyric, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(Some(__obj.lyricoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.LyricOption]](x, x.namespace, x.key, __scope, false)} get,
        __obj.endu45line map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("end-line"), __scope, false) } getOrElse {Nil},
        __obj.endu45paragraph map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("end-paragraph"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence4, None, Some("editorialSequence4"), __scope, false))

  }

  trait DefaultMusicxmlLyricSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.LyricSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.LyricSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.syllabic map { scalaxb.toXML[com.fdilke.musicxml.Syllabic](_, None, Some("syllabic"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Textu45elementu45data](__obj.text, None, Some("text"), __scope, false),
        __obj.lyricsequence2 flatMap { scalaxb.toXML[com.fdilke.musicxml.LyricSequence2](_, None, Some("lyricsequence2"), __scope, false) },
        __obj.extend map { scalaxb.toXML[com.fdilke.musicxml.Extend](_, None, Some("extend"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlLyricSequence2Format extends scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.LyricSequence2] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.LyricSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.lyricsequence3 map { scalaxb.toXML[com.fdilke.musicxml.LyricSequence3](_, None, Some("lyricsequence3"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Textu45elementu45data](__obj.text, None, Some("text"), __scope, false))


  }

  trait DefaultMusicxmlLyricSequence3Format extends scalaxb.XMLFormat[com.fdilke.musicxml.LyricSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.LyricSequence3] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.LyricSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Elision](__obj.elision, None, Some("elision"), __scope, false),
        __obj.syllabic map { scalaxb.toXML[com.fdilke.musicxml.Syllabic](_, None, Some("syllabic"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlMordentFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Mordent] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Mordent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Mordent] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Mordent((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@start-note").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@trill-step").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@two-note-turn").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@long").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@approach").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@departure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Mordent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
      __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
      __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      __obj.long foreach { x => attr = scala.xml.Attribute(null, "long", x.toString, attr) }
      __obj.approach foreach { x => attr = scala.xml.Attribute(null, "approach", x.toString, attr) }
      __obj.departure foreach { x => attr = scala.xml.Attribute(null, "departure", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Mordent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlNonu45arpeggiateFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Nonu45arpeggiate] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Nonu45arpeggiate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Nonu45arpeggiate] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Nonu45arpeggiate(scalaxb.fromXML[com.fdilke.musicxml.Topu45bottom]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Nonu45arpeggiate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Nonu45arpeggiate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlNotationsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Notations] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("notations")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Notations] =
      phrase((parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(((scalaxb.ElemName(None, "tied")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Tied](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slur")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Slur](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tuplet")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Tuplet](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "glissando")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Glissando](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slide")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Slide](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ornaments")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Ornaments](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "technical")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Technical](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "articulations")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Articulations](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Dynamics](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fermata")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Fermata](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "arpeggiate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Arpeggiate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "non-arpeggiate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Nonu45arpeggiate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45mark](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-notation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45notation](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Notations(p1,
        p2.toSeq,
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Notations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Notations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence1, None, Some("editorialSequence1"), __scope, false),
        __obj.notationsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.NotationsOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlNoteFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Note] with MusicxmlFullu45noteGroupFormat with MusicxmlDurationGroupFormat with MusicxmlEditorialu45voiceGroupFormat with MusicxmlStaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Note] =
      phrase(((((scalaxb.ElemName(None, "grace")) ~ 
      ((((parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "tie"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.NoteSequence2(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Tie](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      (((scalaxb.ElemName(None, "cue")) ~ 
      (parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.NoteSequence3(scalaxb.fromXML[com.fdilke.musicxml.Empty](p1, scalaxb.ElemName(node) :: stack),
        p2)) }))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.NoteSequence1(scalaxb.fromXML[com.fdilke.musicxml.Grace](p1, scalaxb.ElemName(node) :: stack),
        p2)) }) ||| 
      (((scalaxb.ElemName(None, "cue")) ~ 
      (parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseDurationGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.NoteSequence4(scalaxb.fromXML[com.fdilke.musicxml.Empty](p1, scalaxb.ElemName(node) :: stack),
        p2,
        p3)) }) ||| 
      (((parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "tie"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.NoteSequence5(p1,
        p2,
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Tie](_, scalaxb.ElemName(node) :: stack) })) })) ~ 
      opt(scalaxb.ElemName(None, "instrument")) ~ 
      (parseEditorialu45voiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "type")) ~ 
      rep(scalaxb.ElemName(None, "dot")) ~ 
      opt(scalaxb.ElemName(None, "accidental")) ~ 
      opt(scalaxb.ElemName(None, "time-modification")) ~ 
      opt(scalaxb.ElemName(None, "stem")) ~ 
      opt(scalaxb.ElemName(None, "notehead")) ~ 
      opt(scalaxb.ElemName(None, "notehead-text")) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "beam")) ~ 
      rep(scalaxb.ElemName(None, "notations")) ~ 
      rep(scalaxb.ElemName(None, "lyric")) ~ 
      opt(scalaxb.ElemName(None, "play")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 =>
      com.fdilke.musicxml.Note(p1,
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Instrument](_, scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Noteu45type](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Accidental](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Timeu45modificationable](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Stem](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Notehead](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Noteheadu45text](_, scalaxb.ElemName(node) :: stack) },
        p11,
        p12.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Beam](_, scalaxb.ElemName(node) :: stack) },
        p13.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Notations](_, scalaxb.ElemName(node) :: stack) },
        p14.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Lyric](_, scalaxb.ElemName(node) :: stack) },
        p15.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Play](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@print-dot").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-dot" -> _ },
        (node \ "@print-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-spacing" -> _ },
        (node \ "@print-lyric").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-lyric" -> _ },
        (node \ "@print-leger").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-leger" -> _ },
        (node \ "@dynamics").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dynamics" -> _ },
        (node \ "@end-dynamics").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@end-dynamics" -> _ },
        (node \ "@attack").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@attack" -> _ },
        (node \ "@release").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@release" -> _ },
        (node \ "@time-only").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-only" -> _ },
        (node \ "@pizzicato").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@pizzicato" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Note, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@print-dot", _) => __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
        case ("@print-spacing", _) => __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
        case ("@print-lyric", _) => __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
        case ("@print-leger", _) => __obj.printu45leger foreach { x => attr = scala.xml.Attribute(null, "print-leger", x.toString, attr) }
        case ("@dynamics", _) => __obj.dynamics foreach { x => attr = scala.xml.Attribute(null, "dynamics", x.toString, attr) }
        case ("@end-dynamics", _) => __obj.endu45dynamics foreach { x => attr = scala.xml.Attribute(null, "end-dynamics", x.toString, attr) }
        case ("@attack", _) => __obj.attack foreach { x => attr = scala.xml.Attribute(null, "attack", x.toString, attr) }
        case ("@release", _) => __obj.release foreach { x => attr = scala.xml.Attribute(null, "release", x.toString, attr) }
        case ("@time-only", _) => __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
        case ("@pizzicato", _) => __obj.pizzicato foreach { x => attr = scala.xml.Attribute(null, "pizzicato", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(Some(__obj.noteoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.NoteOption]](x, x.namespace, x.key, __scope, false)} get,
        __obj.instrument map { scalaxb.toXML[com.fdilke.musicxml.Instrument](_, None, Some("instrument"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Editorialu45voiceSequence](__obj.editorialu45voiceSequence3, None, Some("editorialu45voiceSequence3"), __scope, false),
        __obj.typeValue map { scalaxb.toXML[com.fdilke.musicxml.Noteu45type](_, None, Some("type"), __scope, false) } getOrElse {Nil},
        __obj.dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Emptyu45placementable](_, None, Some("dot"), __scope, false) },
        __obj.accidental map { scalaxb.toXML[com.fdilke.musicxml.Accidental](_, None, Some("accidental"), __scope, false) } getOrElse {Nil},
        __obj.timeu45modification map { scalaxb.toXML[com.fdilke.musicxml.Timeu45modificationable](_, None, Some("time-modification"), __scope, false) } getOrElse {Nil},
        __obj.stem map { scalaxb.toXML[com.fdilke.musicxml.Stem](_, None, Some("stem"), __scope, false) } getOrElse {Nil},
        __obj.notehead map { scalaxb.toXML[com.fdilke.musicxml.Notehead](_, None, Some("notehead"), __scope, false) } getOrElse {Nil},
        __obj.noteheadu45text map { scalaxb.toXML[com.fdilke.musicxml.Noteheadu45text](_, None, Some("notehead-text"), __scope, false) } getOrElse {Nil},
        __obj.staffSequence11 map { scalaxb.toXML[com.fdilke.musicxml.StaffSequence](_, None, Some("staffSequence11"), __scope, false) } getOrElse {Nil},
        __obj.beam flatMap { scalaxb.toXML[com.fdilke.musicxml.Beam](_, None, Some("beam"), __scope, false) },
        __obj.notations flatMap { scalaxb.toXML[com.fdilke.musicxml.Notations](_, None, Some("notations"), __scope, false) },
        __obj.lyric flatMap { scalaxb.toXML[com.fdilke.musicxml.Lyric](_, None, Some("lyric"), __scope, false) },
        __obj.play map { scalaxb.toXML[com.fdilke.musicxml.Play](_, None, Some("play"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlNoteSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.NoteSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.NoteSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Grace](__obj.grace, None, Some("grace"), __scope, false),
        Some(__obj.noteoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.NoteOption2]](x, x.namespace, x.key, __scope, false)} get)


  }

  trait DefaultMusicxmlNoteSequence2Format extends scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.NoteSequence2] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.NoteSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Fullu45noteSequence](__obj.fullu45noteSequence1, None, Some("fullu45noteSequence1"), __scope, false),
        __obj.tie flatMap { scalaxb.toXML[com.fdilke.musicxml.Tie](_, None, Some("tie"), __scope, false) })


  }

  trait DefaultMusicxmlNoteSequence3Format extends scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.NoteSequence3] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.NoteSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Empty](__obj.cue, None, Some("cue"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Fullu45noteSequence](__obj.fullu45noteSequence2, None, Some("fullu45noteSequence2"), __scope, false))


  }

  trait DefaultMusicxmlNoteSequence4Format extends scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence4] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.NoteSequence4] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.NoteSequence4, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Empty](__obj.cue, None, Some("cue"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.Fullu45noteSequence](__obj.fullu45noteSequence2, None, Some("fullu45noteSequence2"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.DurationSequence](__obj.durationSequence3, None, Some("durationSequence3"), __scope, false))


  }

  trait DefaultMusicxmlNoteSequence5Format extends scalaxb.XMLFormat[com.fdilke.musicxml.NoteSequence5] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.NoteSequence5] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.NoteSequence5, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Fullu45noteSequence](__obj.fullu45noteSequence1, None, Some("fullu45noteSequence1"), __scope, false),
        scalaxb.toXML[com.fdilke.musicxml.DurationSequence](__obj.durationSequence2, None, Some("durationSequence2"), __scope, false),
        __obj.tie flatMap { scalaxb.toXML[com.fdilke.musicxml.Tie](_, None, Some("tie"), __scope, false) })


  }

  trait DefaultMusicxmlNoteu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Noteu45type] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Noteu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Noteu45type] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Noteu45type(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Noteu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Noteu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlNoteheadFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Notehead] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Notehead] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Notehead] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Notehead(scalaxb.fromXML[com.fdilke.musicxml.Noteheadu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@filled").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Notehead, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.filled foreach { x => attr = scala.xml.Attribute(null, "filled", x.toString, attr) }
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Notehead, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlNoteheadu45textFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Noteheadu45text] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("notehead-text")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Noteheadu45text] =
      phrase(rep(((scalaxb.ElemName(None, "display-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Noteheadu45text(p1.toSeq: _*) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Noteheadu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.noteheadu45textoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Noteheadu45textOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlOrnamentsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Ornaments] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("ornaments")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Ornaments] =
      phrase(rep(((((scalaxb.ElemName(None, "trill-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "delayed-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "delayed-inverted-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "vertical-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-vertical-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "shake")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "wavy-line")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Wavyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mordent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Mordent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-mordent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Mordent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "schleifer")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tremolo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Tremolo](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "haydn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-ornament")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      rep(scalaxb.ElemName(None, "accidental-mark"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.OrnamentsSequence1(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Accidentalu45mark](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      com.fdilke.musicxml.Ornaments(p1.toSeq,
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Ornaments, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Ornaments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ornamentssequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.OrnamentsSequence1](_, None, Some("ornamentssequence1"), __scope, false) })

  }

  trait DefaultMusicxmlOrnamentsSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.OrnamentsSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.OrnamentsSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.OrnamentsSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(Some(__obj.ornamentsoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.OrnamentsOption]](x, x.namespace, x.key, __scope, false)} get,
        __obj.accidentalu45mark flatMap { scalaxb.toXML[com.fdilke.musicxml.Accidentalu45mark](_, None, Some("accidental-mark"), __scope, false) })


  }

  trait DefaultMusicxmlOtheru45notationFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45notation] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45notation] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45notation] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45notation(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45single]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45notation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45notation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlOtheru45placementu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45placementu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45placementu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45placementu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45placementu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45placementu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45placementu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlOtheru45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Otheru45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Otheru45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Otheru45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Otheru45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Otheru45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Otheru45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlPitchFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Pitch] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("pitch")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Pitch] =
      phrase((scalaxb.ElemName(None, "step")) ~ 
      opt(scalaxb.ElemName(None, "alter")) ~ 
      (scalaxb.ElemName(None, "octave")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Pitch(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Pitch, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Step](__obj.step, None, Some("step"), __scope, false),
        __obj.alter map { scalaxb.toXML[BigDecimal](_, None, Some("alter"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.octave, None, Some("octave"), __scope, false))

  }

  trait DefaultMusicxmlPlacementu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Placementu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Placementu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Placementu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Placementu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Placementu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Placementu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlRestFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Rest] with MusicxmlDisplayu45stepu45octaveGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("rest")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Rest] =
      phrase(opt(parseDisplayu45stepu45octaveGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Rest(p1,
        (node \ "@measure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Rest, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.measure foreach { x => attr = scala.xml.Attribute(null, "measure", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Rest, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.displayu45stepu45octaveSequence1 map { scalaxb.toXML[com.fdilke.musicxml.Displayu45stepu45octaveSequence](_, None, Some("displayu45stepu45octaveSequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlSlideFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Slide] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Slide] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Slide] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Slide(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@first-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Slide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
      __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.toString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Slide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlSlurFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Slur] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Slur] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Slur] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Slur(scalaxb.fromXML[com.fdilke.musicxml.Startu45stopu45continue]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@orientation").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Overu45under](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-x2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-y2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-offset").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-offset2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Slur, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
      __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.toString, attr) }
      __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.toString, attr) }
      __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.toString, attr) }
      __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.toString, attr) }
      __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.toString, attr) }
      __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Slur, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlStemFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Stem] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Stem] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Stem] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Stem(scalaxb.fromXML[com.fdilke.musicxml.Stemu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Stem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Stem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlStrongu45accentFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Strongu45accent] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Strongu45accent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Strongu45accent] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Strongu45accent((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Upu45downType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Upu45downType](scala.xml.Text("up"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Strongu45accent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      if (__obj.typeValue.toString != "up") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Strongu45accent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlStyleu45textFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Styleu45text] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Styleu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Styleu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Styleu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Styleu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Styleu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTapFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tap] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tap] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tap] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tap(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@hand").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tapu45hand](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tap, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.hand foreach { x => attr = scala.xml.Attribute(null, "hand", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tap, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTechnicalFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Technical] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("technical")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Technical] =
      phrase(rep(((scalaxb.ElemName(None, "up-bow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "down-bow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmonic")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harmonic](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "open-string")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "thumb-position")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fingering")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Fingering](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pluck")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Placementu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "double-tongue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "triple-tongue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stopped")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "snap-pizzicato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fret")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Fret](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "string")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.StringType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "hammer-on")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Hammeru45onu45pullu45off](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pull-off")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Hammeru45onu45pullu45off](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bend](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tap")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Tap](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "heel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Heelu45toe](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "toe")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Heelu45toe](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fingernails")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "hole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Hole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Arrow](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "handbell")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Handbell](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "brass-bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "flip")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "smear")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "open")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "half-muted")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmon-mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harmonu45mute](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "golpe")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-technical")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.fdilke.musicxml.Technical(p1.toSeq,
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Technical, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Technical, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.technicaloption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.TechnicalOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlTextu45elementu45dataFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Textu45elementu45data] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Textu45elementu45data] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45elementu45data] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Textu45elementu45data(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dir").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Textu45elementu45data, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
      __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
      __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
      __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Textu45elementu45data, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTieFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tie] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tie] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tie] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tie(scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@time-only").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tie, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tie, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlTiedFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tied] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tied] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tied] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tied(scalaxb.fromXML[com.fdilke.musicxml.Tiedu45type]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@orientation").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Overu45under](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-x2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-y2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-offset").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bezier-offset2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tied, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
      __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.toString, attr) }
      __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.toString, attr) }
      __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.toString, attr) }
      __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.toString, attr) }
      __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.toString, attr) }
      __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlTimeu45modificationableFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45modificationable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45modificationable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("metronome-tuplet")) => Right(scalaxb.fromXML[com.fdilke.musicxml.Metronomeu45tuplet](node, stack))
          case _ => Right(scalaxb.fromXML[com.fdilke.musicxml.Timeu45modification](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: com.fdilke.musicxml.Timeu45modificationable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: com.fdilke.musicxml.Metronomeu45tuplet => scalaxb.toXML[com.fdilke.musicxml.Metronomeu45tuplet](x, __namespace, __elementLabel, __scope, true)
      case x: com.fdilke.musicxml.Timeu45modification => scalaxb.toXML[com.fdilke.musicxml.Timeu45modification](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultMusicxmlTimeu45modificationFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Timeu45modification] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("time-modification")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Timeu45modification] =
      phrase((scalaxb.ElemName(None, "actual-notes")) ~ 
      (scalaxb.ElemName(None, "normal-notes")) ~ 
      opt(((scalaxb.ElemName(None, "normal-type")) ~ 
      rep(scalaxb.ElemName(None, "normal-dot"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Timeu45modificationableSequence1(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Timeu45modification(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Timeu45modification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.actualu45notes, None, Some("actual-notes"), __scope, false),
        scalaxb.toXML[BigInt](__obj.normalu45notes, None, Some("normal-notes"), __scope, false),
        __obj.timeu45modificationablesequence1 map { scalaxb.toXML[com.fdilke.musicxml.Timeu45modificationableSequence1](_, None, Some("timeu45modificationablesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlTimeu45modificationableSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45modificationableSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45modificationableSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Timeu45modificationableSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Noteu45typeu45value](__obj.normalu45type, None, Some("normal-type"), __scope, false),
        __obj.normalu45dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("normal-dot"), __scope, false) })


  }

  trait DefaultMusicxmlTremoloFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tremolo] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tremolo] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tremolo] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tremolo(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tremolou45type](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Tremolou45type](scala.xml.Text("single"), scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tremolo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.typeValue.toString != "single") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tremolo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTupletFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Tuplet] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("tuplet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Tuplet] =
      phrase(opt(scalaxb.ElemName(None, "tuplet-actual")) ~ 
      opt(scalaxb.ElemName(None, "tuplet-normal")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Tuplet(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tupletu45portion](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tupletu45portion](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@show-number").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Showu45tuplet](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@show-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Showu45tuplet](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@line-shape").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45shape](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tuplet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.showu45number foreach { x => attr = scala.xml.Attribute(null, "show-number", x.toString, attr) }
      __obj.showu45type foreach { x => attr = scala.xml.Attribute(null, "show-type", x.toString, attr) }
      __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tuplet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tupletu45actual map { scalaxb.toXML[com.fdilke.musicxml.Tupletu45portion](_, None, Some("tuplet-actual"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45normal map { scalaxb.toXML[com.fdilke.musicxml.Tupletu45portion](_, None, Some("tuplet-normal"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlTupletu45dotFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45dot] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tupletu45dot] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tupletu45dot] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tupletu45dot((node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tupletu45dot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tupletu45dot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlTupletu45numberFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45number] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tupletu45number] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tupletu45number] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tupletu45number(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tupletu45number, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tupletu45number, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlTupletu45portionFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Tupletu45portion] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("tuplet-portion")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Tupletu45portion] =
      phrase(opt(scalaxb.ElemName(None, "tuplet-number")) ~ 
      opt(scalaxb.ElemName(None, "tuplet-type")) ~ 
      rep(scalaxb.ElemName(None, "tuplet-dot")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Tupletu45portion(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tupletu45number](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Tupletu45type](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Tupletu45dot](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Tupletu45portion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tupletu45number map { scalaxb.toXML[com.fdilke.musicxml.Tupletu45number](_, None, Some("tuplet-number"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45type map { scalaxb.toXML[com.fdilke.musicxml.Tupletu45type](_, None, Some("tuplet-type"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Tupletu45dot](_, None, Some("tuplet-dot"), __scope, false) })

  }

  trait DefaultMusicxmlTupletu45typeFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Tupletu45type] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Tupletu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Tupletu45type] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Tupletu45type(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Tupletu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Tupletu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlUnpitchedFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Unpitched] with MusicxmlDisplayu45stepu45octaveGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("unpitched")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Unpitched] =
      phrase(opt(parseDisplayu45stepu45octaveGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Unpitched(p1) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Unpitched, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.displayu45stepu45octaveSequence1 map { scalaxb.toXML[com.fdilke.musicxml.Displayu45stepu45octaveSequence](_, None, Some("displayu45stepu45octaveSequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlCreditFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Credit] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("credit")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Credit] =
      phrase(rep(scalaxb.ElemName(None, "credit-type")) ~ 
      rep(scalaxb.ElemName(None, "link")) ~ 
      rep(scalaxb.ElemName(None, "bookmark")) ~ 
      (((scalaxb.ElemName(None, "credit-image")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Image](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((((scalaxb.ElemName(None, "credit-words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "credit-symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack))))) ~ 
      rep((rep(scalaxb.ElemName(None, "link")) ~ 
      rep(scalaxb.ElemName(None, "bookmark")) ~ 
      (((scalaxb.ElemName(None, "credit-words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "credit-symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.CreditSequence2(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Link](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Bookmark](_, scalaxb.ElemName(node) :: stack) },
        p3) })) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.CreditSequence1(p1,
        p2.toSeq)) })) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.fdilke.musicxml.Credit(p1.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Link](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Bookmark](_, scalaxb.ElemName(node) :: stack) },
        p4,
        (node \ "@page").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Credit, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.page foreach { x => attr = scala.xml.Attribute(null, "page", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Credit, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.creditu45type flatMap { scalaxb.toXML[String](_, None, Some("credit-type"), __scope, false) },
        __obj.link flatMap { scalaxb.toXML[com.fdilke.musicxml.Link](_, None, Some("link"), __scope, false) },
        __obj.bookmark flatMap { scalaxb.toXML[com.fdilke.musicxml.Bookmark](_, None, Some("bookmark"), __scope, false) },
        Some(__obj.creditoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.CreditOption]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultMusicxmlCreditSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.CreditSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.CreditSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.CreditSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(Some(__obj.creditoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.CreditOption2]](x, x.namespace, x.key, __scope, false)} get,
        __obj.creditsequence2 flatMap { scalaxb.toXML[com.fdilke.musicxml.CreditSequence2](_, None, Some("creditsequence2"), __scope, false) })


  }

  trait DefaultMusicxmlCreditSequence2Format extends scalaxb.XMLFormat[com.fdilke.musicxml.CreditSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.CreditSequence2] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.CreditSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.link flatMap { scalaxb.toXML[com.fdilke.musicxml.Link](_, None, Some("link"), __scope, false) },
        __obj.bookmark flatMap { scalaxb.toXML[com.fdilke.musicxml.Bookmark](_, None, Some("bookmark"), __scope, false) },
        Some(__obj.creditoption3) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.CreditOption3]](x, x.namespace, x.key, __scope, false)} get)


  }

  trait DefaultMusicxmlDefaultsFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Defaults] with MusicxmlLayoutGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("defaults")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Defaults] =
      phrase(opt(scalaxb.ElemName(None, "scaling")) ~ 
      (parseLayoutGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "appearance")) ~ 
      opt(scalaxb.ElemName(None, "music-font")) ~ 
      opt(scalaxb.ElemName(None, "word-font")) ~ 
      rep(scalaxb.ElemName(None, "lyric-font")) ~ 
      rep(scalaxb.ElemName(None, "lyric-language")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      com.fdilke.musicxml.Defaults(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Scaling](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Appearance](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Emptyu45font](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Emptyu45font](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Lyricu45font](_, scalaxb.ElemName(node) :: stack) },
        p7.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Lyricu45language](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Defaults, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.scaling map { scalaxb.toXML[com.fdilke.musicxml.Scaling](_, None, Some("scaling"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.LayoutSequence](__obj.layoutSequence2, None, Some("layoutSequence2"), __scope, false),
        __obj.appearance map { scalaxb.toXML[com.fdilke.musicxml.Appearance](_, None, Some("appearance"), __scope, false) } getOrElse {Nil},
        __obj.musicu45font map { scalaxb.toXML[com.fdilke.musicxml.Emptyu45font](_, None, Some("music-font"), __scope, false) } getOrElse {Nil},
        __obj.wordu45font map { scalaxb.toXML[com.fdilke.musicxml.Emptyu45font](_, None, Some("word-font"), __scope, false) } getOrElse {Nil},
        __obj.lyricu45font flatMap { scalaxb.toXML[com.fdilke.musicxml.Lyricu45font](_, None, Some("lyric-font"), __scope, false) },
        __obj.lyricu45language flatMap { scalaxb.toXML[com.fdilke.musicxml.Lyricu45language](_, None, Some("lyric-language"), __scope, false) })

  }

  trait DefaultMusicxmlEmptyu45fontFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Emptyu45font] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Emptyu45font] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Emptyu45font] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Emptyu45font((node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Emptyu45font, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Emptyu45font, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlGroupu45barlineFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45barline] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Groupu45barline] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45barline] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Groupu45barline(scalaxb.fromXML[com.fdilke.musicxml.Groupu45barlineu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Groupu45barline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Groupu45barline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlGroupu45nameFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45name] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Groupu45name] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45name] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Groupu45name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Groupu45name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Groupu45name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlGroupu45symbolFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Groupu45symbol] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Groupu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45symbol] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Groupu45symbol(scalaxb.fromXML[com.fdilke.musicxml.Groupu45symbolu45value](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Groupu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Groupu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlLyricu45fontFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lyricu45font] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Lyricu45font] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lyricu45font] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lyricu45font((node \ "@number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Lyricu45font, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Lyricu45font, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlLyricu45languageFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Lyricu45language] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Lyricu45language] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lyricu45language] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lyricu45language((node \ "@number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@{http://www.w3.org/XML/1998/namespace}lang"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Lyricu45language, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Lyricu45language, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlOpusFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Opus] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Opus] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Opus] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Opus(scalaxb.fromXML[java.net.URI]((node \ "@{http://www.w3.org/1999/xlink}href"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[com.fdilke.musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack),
        (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Show](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack) },
        (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Actuate](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Opus, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
      __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
      __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
      if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
      if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Opus, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMusicxmlPartu45groupFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Partu45group] with MusicxmlEditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("part-group")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Partu45group] =
      phrase(opt(scalaxb.ElemName(None, "group-name")) ~ 
      opt(scalaxb.ElemName(None, "group-name-display")) ~ 
      opt(scalaxb.ElemName(None, "group-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "group-abbreviation-display")) ~ 
      opt(scalaxb.ElemName(None, "group-symbol")) ~ 
      opt(scalaxb.ElemName(None, "group-barline")) ~ 
      opt(scalaxb.ElemName(None, "group-time")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      com.fdilke.musicxml.Partu45group(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Groupu45name](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Groupu45name](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Groupu45symbol](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Groupu45barline](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p8,
        scalaxb.fromXML[com.fdilke.musicxml.Startu45stop]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Partu45group, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Partu45group, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.groupu45name map { scalaxb.toXML[com.fdilke.musicxml.Groupu45name](_, None, Some("group-name"), __scope, false) } getOrElse {Nil},
        __obj.groupu45nameu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("group-name-display"), __scope, false) } getOrElse {Nil},
        __obj.groupu45abbreviation map { scalaxb.toXML[com.fdilke.musicxml.Groupu45name](_, None, Some("group-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.groupu45abbreviationu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("group-abbreviation-display"), __scope, false) } getOrElse {Nil},
        __obj.groupu45symbol map { scalaxb.toXML[com.fdilke.musicxml.Groupu45symbol](_, None, Some("group-symbol"), __scope, false) } getOrElse {Nil},
        __obj.groupu45barline map { scalaxb.toXML[com.fdilke.musicxml.Groupu45barline](_, None, Some("group-barline"), __scope, false) } getOrElse {Nil},
        __obj.groupu45time map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("group-time"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.EditorialSequence](__obj.editorialSequence8, None, Some("editorialSequence8"), __scope, false))

  }

  trait DefaultMusicxmlPartu45listFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Partu45list] with MusicxmlPartu45groupGroupFormat with MusicxmlScoreu45partGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("part-list")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Partu45list] =
      phrase(rep(parsePartu45groupGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseScoreu45partGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep((parsePartu45groupGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      (parseScoreu45partGroup(node, scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Partu45list(p1.toSeq,
        p2,
        p3.toSeq) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Partu45list, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.partu45groupSequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.Partu45groupSequence](_, None, Some("partu45groupSequence1"), __scope, false) },
        scalaxb.toXML[com.fdilke.musicxml.Scoreu45partSequence](__obj.scoreu45partSequence2, None, Some("scoreu45partSequence2"), __scope, false),
        __obj.partu45listoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlPartu45nameFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Partu45name] with scalaxb.CanWriteChildNodes[com.fdilke.musicxml.Partu45name] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Partu45name] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Partu45name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Partu45name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Partu45name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMusicxmlScoreu45instrumentFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scoreu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("score-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45instrument] =
      phrase((scalaxb.ElemName(None, "instrument-name")) ~ 
      opt(scalaxb.ElemName(None, "instrument-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "instrument-sound")) ~ 
      opt(((scalaxb.ElemName(None, "solo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ensemble")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "virtual-instrument")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.fdilke.musicxml.Scoreu45instrument(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Virtualu45instrument](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Scoreu45instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Scoreu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.instrumentu45name, None, Some("instrument-name"), __scope, false),
        __obj.instrumentu45abbreviation map { scalaxb.toXML[String](_, None, Some("instrument-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.instrumentu45sound map { scalaxb.toXML[String](_, None, Some("instrument-sound"), __scope, false) } getOrElse {Nil},
        __obj.scoreu45instrumentoption map { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.virtualu45instrument map { scalaxb.toXML[com.fdilke.musicxml.Virtualu45instrument](_, None, Some("virtual-instrument"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlScoreu45partFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scoreu45part] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("score-part")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45part] =
      phrase(opt(scalaxb.ElemName(None, "identification")) ~ 
      (scalaxb.ElemName(None, "part-name")) ~ 
      opt(scalaxb.ElemName(None, "part-name-display")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation-display")) ~ 
      rep(scalaxb.ElemName(None, "group")) ~ 
      rep(scalaxb.ElemName(None, "score-instrument")) ~ 
      rep((opt(scalaxb.ElemName(None, "midi-device")) ~ 
      opt(scalaxb.ElemName(None, "midi-instrument"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Scoreu45partSequence1(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Midiu45device](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Midiu45instrument](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      com.fdilke.musicxml.Scoreu45part(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Partu45name](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Partu45name](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p7.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Scoreu45instrument](_, scalaxb.ElemName(node) :: stack) },
        p8.toSeq,
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Scoreu45part, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Scoreu45part, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.identification map { scalaxb.toXML[com.fdilke.musicxml.Identification](_, None, Some("identification"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.fdilke.musicxml.Partu45name](__obj.partu45name, None, Some("part-name"), __scope, false),
        __obj.partu45nameu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("part-name-display"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviation map { scalaxb.toXML[com.fdilke.musicxml.Partu45name](_, None, Some("part-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviationu45display map { scalaxb.toXML[com.fdilke.musicxml.Nameu45display](_, None, Some("part-abbreviation-display"), __scope, false) } getOrElse {Nil},
        __obj.group flatMap { scalaxb.toXML[String](_, None, Some("group"), __scope, false) },
        __obj.scoreu45instrument flatMap { scalaxb.toXML[com.fdilke.musicxml.Scoreu45instrument](_, None, Some("score-instrument"), __scope, false) },
        __obj.scoreu45partsequence1 flatMap { scalaxb.toXML[com.fdilke.musicxml.Scoreu45partSequence1](_, None, Some("scoreu45partsequence1"), __scope, false) })

  }

  trait DefaultMusicxmlScoreu45partSequence1Format extends scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45partSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Scoreu45partSequence1] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Scoreu45partSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.midiu45device map { scalaxb.toXML[com.fdilke.musicxml.Midiu45device](_, None, Some("midi-device"), __scope, false) } getOrElse {Nil},
        __obj.midiu45instrument map { scalaxb.toXML[com.fdilke.musicxml.Midiu45instrument](_, None, Some("midi-instrument"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlVirtualu45instrumentFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Virtualu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("virtual-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Virtualu45instrument] =
      phrase(opt(scalaxb.ElemName(None, "virtual-library")) ~ 
      opt(scalaxb.ElemName(None, "virtual-name")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Virtualu45instrument(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Virtualu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.virtualu45library map { scalaxb.toXML[String](_, None, Some("virtual-library"), __scope, false) } getOrElse {Nil},
        __obj.virtualu45name map { scalaxb.toXML[String](_, None, Some("virtual-name"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlWorkFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Work] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("work")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Work] =
      phrase(opt(scalaxb.ElemName(None, "work-number")) ~ 
      opt(scalaxb.ElemName(None, "work-title")) ~ 
      opt(scalaxb.ElemName(None, "opus")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.fdilke.musicxml.Work(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Opus](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.fdilke.musicxml.Work, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.worku45number map { scalaxb.toXML[String](_, None, Some("work-number"), __scope, false) } getOrElse {Nil},
        __obj.worku45title map { scalaxb.toXML[String](_, None, Some("work-title"), __scope, false) } getOrElse {Nil},
        __obj.opus map { scalaxb.toXML[com.fdilke.musicxml.Opus](_, None, Some("opus"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxmlMeasureFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Measure] with MusicxmlMusicu45dataGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Measure] =
      phrase(rep(parseMusicu45dataGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Measure(p1.toSeq,
        scalaxb.fromXML[String]((node \ "@number"), scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@implicit").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@non-controlling").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Measure, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
      __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Measure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.musicu45dataOption11 flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Musicu45dataOption1]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlPartFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Part] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Part] =
      phrase(rep(scalaxb.ElemName(None, "measure")) ^^
      { case p1 =>
      com.fdilke.musicxml.Part(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Measure](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Part, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Part, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.measure flatMap { scalaxb.toXML[com.fdilke.musicxml.Measure](_, None, Some("measure"), __scope, false) })

  }

  trait DefaultMusicxmlScoreu45partwiseFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scoreu45partwise] with MusicxmlScoreu45headerGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45partwise] =
      phrase((parseScoreu45headerGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "part")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Scoreu45partwise(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Part](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@version").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Scoreu45partwise, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Scoreu45partwise, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Scoreu45headerSequence](__obj.scoreu45headerSequence1, None, Some("scoreu45headerSequence1"), __scope, false),
        __obj.part flatMap { scalaxb.toXML[com.fdilke.musicxml.Part](_, None, Some("part"), __scope, false) })

  }

  trait DefaultMusicxmlPart2Format extends scalaxb.ElemNameParser[com.fdilke.musicxml.Part2] with MusicxmlMusicu45dataGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Part2] =
      phrase(rep(parseMusicu45dataGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      com.fdilke.musicxml.Part2(p1.toSeq,
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Part2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Part2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.musicu45dataOption11 flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Musicu45dataOption1]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxmlMeasure2Format extends scalaxb.ElemNameParser[com.fdilke.musicxml.Measure2] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Measure2] =
      phrase(rep(scalaxb.ElemName(None, "part")) ^^
      { case p1 =>
      com.fdilke.musicxml.Measure2(p1.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Part2](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@number"), scalaxb.ElemName(node) :: stack),
        (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@implicit").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@non-controlling").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Measure2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
      __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Measure2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.part flatMap { scalaxb.toXML[com.fdilke.musicxml.Part2](_, None, Some("part"), __scope, false) })

  }

  trait DefaultMusicxmlScoreu45timewiseFormat extends scalaxb.ElemNameParser[com.fdilke.musicxml.Scoreu45timewise] with MusicxmlScoreu45headerGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45timewise] =
      phrase((parseScoreu45headerGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      rep(scalaxb.ElemName(None, "measure")) ^^
      { case p1 ~ p2 =>
      com.fdilke.musicxml.Scoreu45timewise(p1,
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Measure2](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@version").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.fdilke.musicxml.Scoreu45timewise, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.fdilke.musicxml.Scoreu45timewise, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Scoreu45headerSequence](__obj.scoreu45headerSequence1, None, Some("scoreu45headerSequence1"), __scope, false),
        __obj.measure flatMap { scalaxb.toXML[com.fdilke.musicxml.Measure2](_, None, Some("measure"), __scope, false) })

  }


/** The score-part element is defined within a group due to its multiple uses within the part-list element.
*/
  trait MusicxmlScoreu45partGroupFormat extends scalaxb.AnyElemNameParser {
    def parseScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45partSequence] =
      (((scalaxb.ElemName(None, "score-part"))) ^^ 
        { case p1 => com.fdilke.musicxml.Scoreu45partSequence(scalaxb.fromXML[com.fdilke.musicxml.Scoreu45part](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "score-part"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.Scoreu45partSequence(scalaxb.fromXML[com.fdilke.musicxml.Scoreu45part](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "score-part")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Scoreu45part](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlScoreu45partSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45partSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Scoreu45partSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Scoreu45partSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.fdilke.musicxml.Scoreu45part](__obj.scoreu45part, None, Some("score-part"), __scope, false)


  }


/** The score-header group contains basic score metadata about the work and movement, score-wide defaults for layout and fonts, credits that appear on the first or following pages, and the part list.
*/
  trait MusicxmlScoreu45headerGroupFormat extends scalaxb.AnyElemNameParser {
    def parseScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Scoreu45headerSequence] =
      ((opt(scalaxb.ElemName(None, "work")) ~ 
      opt(scalaxb.ElemName(None, "movement-number")) ~ 
      opt(scalaxb.ElemName(None, "movement-title")) ~ 
      opt(scalaxb.ElemName(None, "identification")) ~ 
      opt(scalaxb.ElemName(None, "defaults")) ~ 
      rep(scalaxb.ElemName(None, "credit")) ~ 
      (scalaxb.ElemName(None, "part-list"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => com.fdilke.musicxml.Scoreu45headerSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Work](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Defaults](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Credit](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Partu45list](p7, scalaxb.ElemName(node) :: stack)) })
  
    def parseScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "work")) ~ 
      opt(scalaxb.ElemName(None, "movement-number")) ~ 
      opt(scalaxb.ElemName(None, "movement-title")) ~ 
      opt(scalaxb.ElemName(None, "identification")) ~ 
      opt(scalaxb.ElemName(None, "defaults")) ~ 
      rep(scalaxb.ElemName(None, "credit")) ~ 
      (scalaxb.ElemName(None, "part-list"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => scalaxb.DataRecord(com.fdilke.musicxml.Scoreu45headerSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Work](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Defaults](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Credit](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.fdilke.musicxml.Partu45list](p7, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "work")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Work](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "movement-number")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "movement-title")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "identification")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Identification](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "defaults")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Defaults](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "credit")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Credit](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "part-list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Partu45list](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList,
        p11,
        p12.toList,
        Seq(p13),
        p14.toList) })
  }

  trait DefaultMusicxmlScoreu45headerSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Scoreu45headerSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Scoreu45headerSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Scoreu45headerSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.work map { scalaxb.toXML[com.fdilke.musicxml.Work](_, None, Some("work"), __scope, false) } getOrElse {Nil},
        __obj.movementu45number map { scalaxb.toXML[String](_, None, Some("movement-number"), __scope, false) } getOrElse {Nil},
        __obj.movementu45title map { scalaxb.toXML[String](_, None, Some("movement-title"), __scope, false) } getOrElse {Nil},
        __obj.identification map { scalaxb.toXML[com.fdilke.musicxml.Identification](_, None, Some("identification"), __scope, false) } getOrElse {Nil},
        __obj.defaults map { scalaxb.toXML[com.fdilke.musicxml.Defaults](_, None, Some("defaults"), __scope, false) } getOrElse {Nil},
        __obj.credit flatMap { scalaxb.toXML[com.fdilke.musicxml.Credit](_, None, Some("credit"), __scope, false) },
        scalaxb.toXML[com.fdilke.musicxml.Partu45list](__obj.partu45list, None, Some("part-list"), __scope, false))


  }


/** The part-group element is defined within a group due to its multiple uses within the part-list element.
*/
  trait MusicxmlPartu45groupGroupFormat extends scalaxb.AnyElemNameParser {
    def parsePartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Partu45groupSequence] =
      (((scalaxb.ElemName(None, "part-group"))) ^^ 
        { case p1 => com.fdilke.musicxml.Partu45groupSequence(scalaxb.fromXML[com.fdilke.musicxml.Partu45group](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parsePartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "part-group"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.Partu45groupSequence(scalaxb.fromXML[com.fdilke.musicxml.Partu45group](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedPartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "part-group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Partu45group](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlPartu45groupSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Partu45groupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Partu45groupSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Partu45groupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.fdilke.musicxml.Partu45group](__obj.partu45group, None, Some("part-group"), __scope, false)


  }


/** The music-data group contains the basic musical data that is either associated with a part or a measure, depending on whether the partwise or timewise hierarchy is used.
*/
  trait MusicxmlMusicu45dataGroupFormat extends scalaxb.AnyElemNameParser {
    def parseMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[com.fdilke.musicxml.Musicu45dataOption1]] =
      (((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))))
  
    def parseMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[com.fdilke.musicxml.Musicu45dataOption1]] =
      (((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** The full-note group is a sequence of the common note elements between cue/grace notes and regular (full) notes: pitch, chord, and rest information, but not duration (cue and grace notes do not have duration encoded). Unpitched elements are used for unpitched percussion, speaking voice, and other musical elements lacking determinate pitch.
*/
  trait MusicxmlFullu45noteGroupFormat extends scalaxb.AnyElemNameParser {
    def parseFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Fullu45noteSequence] =
      ((opt(scalaxb.ElemName(None, "chord")) ~ 
      (((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Fullu45noteSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2) })
  
    def parseFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "chord")) ~ 
      (((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.Fullu45noteSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2)) })
    
    def parsemixedFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "chord")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (((((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxmlFullu45noteSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Fullu45noteSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Fullu45noteSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Fullu45noteSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.chord map { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("chord"), __scope, false) } getOrElse {Nil},
        Some(__obj.fullu45noteoption1) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Fullu45noteOption1]](x, x.namespace, x.key, __scope, false)} get)


  }


/** The display-step-octave group contains the sequence of elements used by both the rest and unpitched elements. This group is used to place rests and unpitched elements on the staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is used, the display-step and display-octave elements are interpreted as if in treble clef, with a G in octave 4 on line 2. If not present, the note is placed on the middle line of the staff, generally used for a one-line staff.
*/
  trait MusicxmlDisplayu45stepu45octaveGroupFormat extends scalaxb.AnyElemNameParser {
    def parseDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Displayu45stepu45octaveSequence] =
      (((scalaxb.ElemName(None, "display-step")) ~ 
      (scalaxb.ElemName(None, "display-octave"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Displayu45stepu45octaveSequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "display-step")) ~ 
      (scalaxb.ElemName(None, "display-octave"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.Displayu45stepu45octaveSequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "display-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "display-octave")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxmlDisplayu45stepu45octaveSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Displayu45stepu45octaveSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Displayu45stepu45octaveSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Displayu45stepu45octaveSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Step](__obj.displayu45step, None, Some("display-step"), __scope, false),
        scalaxb.toXML[BigInt](__obj.displayu45octave, None, Some("display-octave"), __scope, false))


  }


/** The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.
*/
  trait MusicxmlDurationGroupFormat extends scalaxb.AnyElemNameParser {
    def parseDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.DurationSequence] =
      (((scalaxb.ElemName(None, "duration"))) ^^ 
        { case p1 => com.fdilke.musicxml.DurationSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "duration"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.DurationSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "duration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlDurationSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.DurationSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.DurationSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.DurationSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[BigDecimal](__obj.duration, None, Some("duration"), __scope, false)


  }


/** The left-right-margins group specifies horizontal margins in tenths.
*/
  trait MusicxmlLeftu45rightu45marginsGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Leftu45rightu45marginsSequence] =
      (((scalaxb.ElemName(None, "left-margin")) ~ 
      (scalaxb.ElemName(None, "right-margin"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Leftu45rightu45marginsSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "left-margin")) ~ 
      (scalaxb.ElemName(None, "right-margin"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.Leftu45rightu45marginsSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "left-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "right-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxmlLeftu45rightu45marginsSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Leftu45rightu45marginsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Leftu45rightu45marginsSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Leftu45rightu45marginsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.leftu45margin, None, Some("left-margin"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.rightu45margin, None, Some("right-margin"), __scope, false))


  }


/** The layout group specifies the sequence of page, system, and staff layout elements that is common to both the defaults and print elements.
*/
  trait MusicxmlLayoutGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.LayoutSequence] =
      ((opt(scalaxb.ElemName(None, "page-layout")) ~ 
      opt(scalaxb.ElemName(None, "system-layout")) ~ 
      rep(scalaxb.ElemName(None, "staff-layout"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.LayoutSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Pageu45layout](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Systemu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Staffu45layout](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "page-layout")) ~ 
      opt(scalaxb.ElemName(None, "system-layout")) ~ 
      rep(scalaxb.ElemName(None, "staff-layout"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.LayoutSequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Pageu45layout](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Systemu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Staffu45layout](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "page-layout")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Pageu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "system-layout")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Systemu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "staff-layout")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Staffu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5,
        p6.toList) })
  }

  trait DefaultMusicxmlLayoutSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.LayoutSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.LayoutSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.LayoutSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.pageu45layout map { scalaxb.toXML[com.fdilke.musicxml.Pageu45layout](_, None, Some("page-layout"), __scope, false) } getOrElse {Nil},
        __obj.systemu45layout map { scalaxb.toXML[com.fdilke.musicxml.Systemu45layout](_, None, Some("system-layout"), __scope, false) } getOrElse {Nil},
        __obj.staffu45layout flatMap { scalaxb.toXML[com.fdilke.musicxml.Staffu45layout](_, None, Some("staff-layout"), __scope, false) })


  }


/** The all-margins group specifies both horizontal and vertical margins in tenths.
*/
  trait MusicxmlAllu45marginsGroupFormat extends MusicxmlLeftu45rightu45marginsGroupFormat {
    def parseAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Allu45marginsSequence] =
      (((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (scalaxb.ElemName(None, "top-margin")) ~ 
      (scalaxb.ElemName(None, "bottom-margin"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.Allu45marginsSequence(p1,
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p3, scalaxb.ElemName(node) :: stack)) })
  
    def parseAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (scalaxb.ElemName(None, "top-margin")) ~ 
      (scalaxb.ElemName(None, "bottom-margin"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.Allu45marginsSequence(p1,
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p3, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((parsemixedLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "top-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "bottom-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1,
        p2.toList,
        Seq(p3),
        p4.toList,
        Seq(p5),
        p6.toList) })
  }

  trait DefaultMusicxmlAllu45marginsSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Allu45marginsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Allu45marginsSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Allu45marginsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Leftu45rightu45marginsSequence](__obj.leftu45rightu45marginsSequence1, None, Some("leftu45rightu45marginsSequence1"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.topu45margin, None, Some("top-margin"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.bottomu45margin, None, Some("bottom-margin"), __scope, false))


  }


/** A harmony element can contain many stacked chords (e.g. V of II). A sequence of harmony-chord groups is used for this type of secondary function, where V of II would be represented by a harmony-chord with a V function followed by a harmony-chord with a II function.

A root is a pitch name like C, D, E, where a function is an indication like I, II, III. It is an either/or choice to avoid data inconsistency.
*/
  trait MusicxmlHarmonyu45chordGroupFormat extends scalaxb.AnyElemNameParser {
    def parseHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Harmonyu45chordSequence] =
      (((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      (scalaxb.ElemName(None, "kind")) ~ 
      opt(scalaxb.ElemName(None, "inversion")) ~ 
      opt(scalaxb.ElemName(None, "bass")) ~ 
      rep(scalaxb.ElemName(None, "degree"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => com.fdilke.musicxml.Harmonyu45chordSequence(p1,
        scalaxb.fromXML[com.fdilke.musicxml.Kind](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Inversion](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Bass](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Degree](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      (scalaxb.ElemName(None, "kind")) ~ 
      opt(scalaxb.ElemName(None, "inversion")) ~ 
      opt(scalaxb.ElemName(None, "bass")) ~ 
      rep(scalaxb.ElemName(None, "degree"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => scalaxb.DataRecord(com.fdilke.musicxml.Harmonyu45chordSequence(p1,
        scalaxb.fromXML[com.fdilke.musicxml.Kind](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Inversion](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Bass](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Degree](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "kind")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Kind](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "inversion")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Inversion](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "bass")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Bass](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "degree")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Degree](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => Seq.concat(p1,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9,
        p10.toList) })
  }

  trait DefaultMusicxmlHarmonyu45chordSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Harmonyu45chordSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Harmonyu45chordSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Harmonyu45chordSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(Some(__obj.harmonyu45chordoption1) map {x => scalaxb.toXML[scalaxb.DataRecord[com.fdilke.musicxml.Harmonyu45chordOption1]](x, x.namespace, x.key, __scope, false)} get,
        scalaxb.toXML[com.fdilke.musicxml.Kind](__obj.kind, None, Some("kind"), __scope, false),
        __obj.inversion map { scalaxb.toXML[com.fdilke.musicxml.Inversion](_, None, Some("inversion"), __scope, false) } getOrElse {Nil},
        __obj.bass map { scalaxb.toXML[com.fdilke.musicxml.Bass](_, None, Some("bass"), __scope, false) } getOrElse {Nil},
        __obj.degree flatMap { scalaxb.toXML[com.fdilke.musicxml.Degree](_, None, Some("degree"), __scope, false) })


  }


/** The beat-unit group combines elements used repeatedly in the metronome element to specify a note within a metronome mark.
*/
  trait MusicxmlBeatu45unitGroupFormat extends scalaxb.AnyElemNameParser {
    def parseBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Beatu45unitSequence] =
      (((scalaxb.ElemName(None, "beat-unit")) ~ 
      rep(scalaxb.ElemName(None, "beat-unit-dot"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Beatu45unitSequence(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "beat-unit")) ~ 
      rep(scalaxb.ElemName(None, "beat-unit-dot"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.Beatu45unitSequence(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "beat-unit")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "beat-unit-dot")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxmlBeatu45unitSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Beatu45unitSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Beatu45unitSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Beatu45unitSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Noteu45typeu45value](__obj.beatu45unit, None, Some("beat-unit"), __scope, false),
        __obj.beatu45unitu45dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("beat-unit-dot"), __scope, false) })


  }


/** The traditional-key group represents a traditional key signature using the cycle of fifths.
*/
  trait MusicxmlTraditionalu45keyGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Traditionalu45keySequence] =
      ((opt(scalaxb.ElemName(None, "cancel")) ~ 
      (scalaxb.ElemName(None, "fifths")) ~ 
      opt(scalaxb.ElemName(None, "mode"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.Traditionalu45keySequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Cancel](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "cancel")) ~ 
      (scalaxb.ElemName(None, "fifths")) ~ 
      opt(scalaxb.ElemName(None, "mode"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.Traditionalu45keySequence(p1.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Cancel](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "cancel")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Cancel](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "fifths")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "mode")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultMusicxmlTraditionalu45keySequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Traditionalu45keySequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Traditionalu45keySequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Traditionalu45keySequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.cancel map { scalaxb.toXML[com.fdilke.musicxml.Cancel](_, None, Some("cancel"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.fifths, None, Some("fifths"), __scope, false),
        __obj.mode map { scalaxb.toXML[String](_, None, Some("mode"), __scope, false) } getOrElse {Nil})


  }


/** Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
*/
  trait MusicxmlTimeu45signatureGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Timeu45signatureSequence] =
      (((scalaxb.ElemName(None, "beats")) ~ 
      (scalaxb.ElemName(None, "beat-type"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.Timeu45signatureSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "beats")) ~ 
      (scalaxb.ElemName(None, "beat-type"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.Timeu45signatureSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "beats")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "beat-type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxmlTimeu45signatureSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Timeu45signatureSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Timeu45signatureSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Timeu45signatureSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[String](__obj.beats, None, Some("beats"), __scope, false),
        scalaxb.toXML[String](__obj.beatu45type, None, Some("beat-type"), __scope, false))


  }


/** The slash group combines elements used for more complete specification of the slash and beat-repeat measure-style elements. They have the same values as the type and dot elements, and define what the beat is for the display of repetition marks. If not present, the beat is based on the current time signature.
*/
  trait MusicxmlSlashGroupFormat extends scalaxb.AnyElemNameParser {
    def parseSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.SlashSequence] =
      ((opt(((scalaxb.ElemName(None, "slash-type")) ~ 
      rep(scalaxb.ElemName(None, "slash-dot"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.SlashSequence2(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      rep(scalaxb.ElemName(None, "except-voice"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.SlashSequence(p1,
        p2.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(((scalaxb.ElemName(None, "slash-type")) ~ 
      rep(scalaxb.ElemName(None, "slash-dot"))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.SlashSequence2(scalaxb.fromXML[com.fdilke.musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2.toSeq map { scalaxb.fromXML[com.fdilke.musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      rep(scalaxb.ElemName(None, "except-voice"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.SlashSequence(p1,
        p2.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt((((scalaxb.ElemName(None, "slash-type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "slash-dot")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3,
        p4.toList) }) ~ 
      optTextRecord ~ 
      (rep(scalaxb.ElemName(None, "except-voice")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxmlSlashSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.SlashSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.SlashSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.SlashSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.slashsequence2 map { scalaxb.toXML[com.fdilke.musicxml.SlashSequence2](_, None, Some("slashsequence2"), __scope, false) } getOrElse {Nil},
        __obj.exceptu45voice flatMap { scalaxb.toXML[String](_, None, Some("except-voice"), __scope, false) })


  }

  trait DefaultMusicxmlSlashSequence2Format extends scalaxb.XMLFormat[com.fdilke.musicxml.SlashSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.SlashSequence2] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.SlashSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Noteu45typeu45value](__obj.slashu45type, None, Some("slash-type"), __scope, false),
        __obj.slashu45dot flatMap { scalaxb.toXML[com.fdilke.musicxml.Empty](_, None, Some("slash-dot"), __scope, false) })


  }


/** The non-traditional-key group represents a single alteration within a non-traditional key signature. A sequence of these groups makes up a non-traditional key signature
*/
  trait MusicxmlNonu45traditionalu45keyGroupFormat extends scalaxb.AnyElemNameParser {
    def parseNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Nonu45traditionalu45keySequence] =
      (((scalaxb.ElemName(None, "key-step")) ~ 
      (scalaxb.ElemName(None, "key-alter")) ~ 
      opt(scalaxb.ElemName(None, "key-accidental"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.Nonu45traditionalu45keySequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Keyu45accidental](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "key-step")) ~ 
      (scalaxb.ElemName(None, "key-alter")) ~ 
      opt(scalaxb.ElemName(None, "key-accidental"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.Nonu45traditionalu45keySequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[com.fdilke.musicxml.Keyu45accidental](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "key-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "key-alter")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "key-accidental")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Keyu45accidental](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultMusicxmlNonu45traditionalu45keySequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Nonu45traditionalu45keySequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Nonu45traditionalu45keySequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Nonu45traditionalu45keySequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Step](__obj.keyu45step, None, Some("key-step"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.keyu45alter, None, Some("key-alter"), __scope, false),
        __obj.keyu45accidental map { scalaxb.toXML[com.fdilke.musicxml.Keyu45accidental](_, None, Some("key-accidental"), __scope, false) } getOrElse {Nil})


  }


/** The voice is used to distinguish between multiple voices (what MuseData calls tracks) in individual parts. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait MusicxmlVoiceGroupFormat extends scalaxb.AnyElemNameParser {
    def parseVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.VoiceSequence] =
      (((scalaxb.ElemName(None, "voice"))) ^^ 
        { case p1 => com.fdilke.musicxml.VoiceSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "voice"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.VoiceSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "voice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlVoiceSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.VoiceSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.VoiceSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.VoiceSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[String](__obj.voice, None, Some("voice"), __scope, false)


  }


/** The tuning group contains the sequence of elements common to the staff-tuning and accord elements.
*/
  trait MusicxmlTuningGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.TuningSequence] =
      (((scalaxb.ElemName(None, "tuning-step")) ~ 
      opt(scalaxb.ElemName(None, "tuning-alter")) ~ 
      (scalaxb.ElemName(None, "tuning-octave"))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.TuningSequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack)) })
  
    def parseTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "tuning-step")) ~ 
      opt(scalaxb.ElemName(None, "tuning-alter")) ~ 
      (scalaxb.ElemName(None, "tuning-octave"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.TuningSequence(scalaxb.fromXML[com.fdilke.musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "tuning-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "tuning-alter")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "tuning-octave")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        Seq(p5),
        p6.toList) })
  }

  trait DefaultMusicxmlTuningSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.TuningSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.TuningSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.TuningSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.fdilke.musicxml.Step](__obj.tuningu45step, None, Some("tuning-step"), __scope, false),
        __obj.tuningu45alter map { scalaxb.toXML[BigDecimal](_, None, Some("tuning-alter"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.tuningu45octave, None, Some("tuning-octave"), __scope, false))


  }


/** The staff element is defined within a group due to its use by both notes and direction elements.
*/
  trait MusicxmlStaffGroupFormat extends scalaxb.AnyElemNameParser {
    def parseStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.StaffSequence] =
      (((scalaxb.ElemName(None, "staff"))) ^^ 
        { case p1 => com.fdilke.musicxml.StaffSequence(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "staff"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.StaffSequence(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "staff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlStaffSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.StaffSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.StaffSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.StaffSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[BigInt](__obj.staff, None, Some("staff"), __scope, false)


  }


/** The level element specifies editorial information for different MusicXML elements. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait MusicxmlLevelGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.LevelSequence] =
      (((scalaxb.ElemName(None, "level"))) ^^ 
        { case p1 => com.fdilke.musicxml.LevelSequence(scalaxb.fromXML[com.fdilke.musicxml.Level](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "level"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.LevelSequence(scalaxb.fromXML[com.fdilke.musicxml.Level](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "level")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Level](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlLevelSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.LevelSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.LevelSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.LevelSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.fdilke.musicxml.Level](__obj.level, None, Some("level"), __scope, false)


  }


/** The footnote element specifies editorial information that appears in footnotes in the printed score. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait MusicxmlFootnoteGroupFormat extends scalaxb.AnyElemNameParser {
    def parseFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.FootnoteSequence] =
      (((scalaxb.ElemName(None, "footnote"))) ^^ 
        { case p1 => com.fdilke.musicxml.FootnoteSequence(scalaxb.fromXML[com.fdilke.musicxml.Formattedu45text](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "footnote"))) ^^ 
        { case p1 => scalaxb.DataRecord(com.fdilke.musicxml.FootnoteSequence(scalaxb.fromXML[com.fdilke.musicxml.Formattedu45text](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "footnote")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.fdilke.musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxmlFootnoteSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.FootnoteSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.FootnoteSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.FootnoteSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.fdilke.musicxml.Formattedu45text](__obj.footnote, None, Some("footnote"), __scope, false)


  }


/** The editorial-voice-direction group supports the common combination of editorial and voice information for a direction element. It is separate from the editorial-voice element because extensions and restrictions might be different for directions than for the note and forward elements.
*/
  trait MusicxmlEditorialu45voiceu45directionGroupFormat extends MusicxmlFootnoteGroupFormat with MusicxmlLevelGroupFormat with MusicxmlVoiceGroupFormat {
    def parseEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Editorialu45voiceu45directionSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.Editorialu45voiceu45directionSequence(p1,
        p2,
        p3) })
  
    def parseEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.Editorialu45voiceu45directionSequence(p1,
        p2,
        p3)) })
    
    def parsemixedEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedVoiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList,
        p5 getOrElse {Nil},
        p6.toList) })
  }

  trait DefaultMusicxmlEditorialu45voiceu45directionSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Editorialu45voiceu45directionSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Editorialu45voiceu45directionSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Editorialu45voiceu45directionSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[com.fdilke.musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[com.fdilke.musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil},
        __obj.voiceSequence3 map { scalaxb.toXML[com.fdilke.musicxml.VoiceSequence](_, None, Some("voiceSequence3"), __scope, false) } getOrElse {Nil})


  }


/** The editorial-voice group supports the common combination of editorial and voice information for a musical element.
*/
  trait MusicxmlEditorialu45voiceGroupFormat extends MusicxmlFootnoteGroupFormat with MusicxmlLevelGroupFormat with MusicxmlVoiceGroupFormat {
    def parseEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.Editorialu45voiceSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => com.fdilke.musicxml.Editorialu45voiceSequence(p1,
        p2,
        p3) })
  
    def parseEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(com.fdilke.musicxml.Editorialu45voiceSequence(p1,
        p2,
        p3)) })
    
    def parsemixedEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedVoiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList,
        p5 getOrElse {Nil},
        p6.toList) })
  }

  trait DefaultMusicxmlEditorialu45voiceSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.Editorialu45voiceSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Editorialu45voiceSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.Editorialu45voiceSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[com.fdilke.musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[com.fdilke.musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil},
        __obj.voiceSequence3 map { scalaxb.toXML[com.fdilke.musicxml.VoiceSequence](_, None, Some("voiceSequence3"), __scope, false) } getOrElse {Nil})


  }


/** The editorial group specifies editorial information for a musical element.
*/
  trait MusicxmlEditorialGroupFormat extends MusicxmlFootnoteGroupFormat with MusicxmlLevelGroupFormat {
    def parseEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.fdilke.musicxml.EditorialSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => com.fdilke.musicxml.EditorialSequence(p1,
        p2) })
  
    def parseEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(com.fdilke.musicxml.EditorialSequence(p1,
        p2)) })
    
    def parsemixedEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList) })
  }

  trait DefaultMusicxmlEditorialSequenceFormat extends scalaxb.XMLFormat[com.fdilke.musicxml.EditorialSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.EditorialSequence] = Left("don't call me.")
    
    def writes(__obj: com.fdilke.musicxml.EditorialSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[com.fdilke.musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[com.fdilke.musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxmlPartu45nameu45textFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Partu45nameu45text] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Partu45nameu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Partu45nameu45text((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Partu45nameu45text, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
    __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
    __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPartu45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Partu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Partu45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Partu45attributes(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Partu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }
  }

  trait DefaultMusicxmlMeasureu45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Measureu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Measureu45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Measureu45attributes(scalaxb.fromXML[String]((node \ "@number"), scalaxb.ElemName(node) :: stack),
      (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@implicit").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@non-controlling").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Measureu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
    __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
    __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
    __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
    __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
    __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlGroupu45nameu45textFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Groupu45nameu45text] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Groupu45nameu45text] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Groupu45nameu45text((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Groupu45nameu45text, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
    __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLinku45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Linku45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Linku45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Linku45attributes(scalaxb.fromXML[java.net.URI]((node \ "@{http://www.w3.org/1999/xlink}href"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[com.fdilke.musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack),
      (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Show](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Actuate](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.fdilke.musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Linku45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
    attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
    __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
    __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
    if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
    if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
      attr
    }
  }

  trait DefaultMusicxmlElementu45positionFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Elementu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Elementu45position] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Elementu45position((node \ "@element").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@position").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Elementu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
    __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintu45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printu45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printu45attributes((node \ "@staff-spacing").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@new-system").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@new-page").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@blank-page").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@page-number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.staffu45spacing foreach { x => attr = scala.xml.Attribute(null, "staff-spacing", x.toString, attr) }
    __obj.newu45system foreach { x => attr = scala.xml.Attribute(null, "new-system", x.toString, attr) }
    __obj.newu45page foreach { x => attr = scala.xml.Attribute(null, "new-page", x.toString, attr) }
    __obj.blanku45page foreach { x => attr = scala.xml.Attribute(null, "blank-page", x.toString, attr) }
    __obj.pageu45number foreach { x => attr = scala.xml.Attribute(null, "page-number", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlImageu45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Imageu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Imageu45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Imageu45attributes(scalaxb.fromXML[java.net.URI]((node \ "@source"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
      (node \ "@height").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Imageu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "source", __obj.source.toString, attr)
    attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
    __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
    __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
    __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
    __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlYu45positionFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Yu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Yu45position] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Yu45position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Yu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlXu45positionFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Xu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Xu45position] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Xu45position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Xu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlValignu45imageTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Valignu45imageType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Valignu45imageType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Valignu45imageType((node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Valignu45imageType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlValignTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.ValignType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.ValignType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.ValignType((node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.ValignType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlTrillu45soundFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Trillu45sound] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Trillu45sound] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Trillu45sound((node \ "@start-note").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@trill-step").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@two-note-turn").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Trillu45sound, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
    __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
    __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
    __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
    __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
    __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.toString, attr) }
    __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlTextu45rotationFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45rotation] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45rotation] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Textu45rotation((node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Textu45rotation, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlTextu45formattingFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45formatting] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Textu45formatting((node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@dir").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@enclosure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Textu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
    __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
    __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
    __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
    __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
    __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
    __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
    __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
    __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
    __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
    __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
    __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
    __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
    __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlTextu45directionTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45directionType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45directionType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Textu45directionType((node \ "@dir").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Textu45directionType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlTextu45decorationFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Textu45decoration] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Textu45decoration] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Textu45decoration((node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Textu45decoration, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
    __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
    __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlSymbolu45formattingFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Symbolu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Symbolu45formatting] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Symbolu45formatting((node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@dir").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@enclosure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Symbolu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
    __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
    __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
    __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
    __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
    __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
    __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
    __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.toString, attr) }
    __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
    __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
    __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
    __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlSmuflFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Smufl] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Smufl] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Smufl((node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Smufl, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintoutFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printout] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printout] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printout((node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-dot").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-spacing").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-lyric").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printout, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
    __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
    __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
    __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintu45styleu45alignFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45styleu45align] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printu45styleu45align((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printu45styleu45align, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
    __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
    __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintu45styleFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45style] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printu45style] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printu45style((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printu45style, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
    __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
    __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintu45spacingFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45spacing] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printu45spacing] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printu45spacing((node \ "@print-spacing").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printu45spacing, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPrintu45objectFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Printu45object] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Printu45object] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Printu45object((node \ "@print-object").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Printu45object, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPositionFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Position] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.toString, attr) }
    __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.toString, attr) }
    __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.toString, attr) }
    __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlPlacementFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Placement] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Placement] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Placement((node \ "@placement").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Placement, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlOrientationFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Orientation] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Orientation] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Orientation((node \ "@orientation").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Overu45under](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Orientation, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlOptionalu45uniqueu45idFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Optionalu45uniqueu45id] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Optionalu45uniqueu45id] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Optionalu45uniqueu45id((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Optionalu45uniqueu45id, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLineu45typeTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45typeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45typeType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lineu45typeType((node \ "@line-type").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Lineu45typeType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLineu45shapeTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45shapeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45shapeType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lineu45shapeType((node \ "@line-shape").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Lineu45shapeType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLineu45lengthTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45lengthType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45lengthType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lineu45lengthType((node \ "@line-length").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Lineu45length](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Lineu45lengthType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45length foreach { x => attr = scala.xml.Attribute(null, "line-length", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLineu45heightFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Lineu45height] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Lineu45height] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Lineu45height((node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Lineu45height, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLevelu45displayFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Levelu45display] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Levelu45display] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Levelu45display((node \ "@parentheses").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bracket").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@size").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Levelu45display, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
    __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
    __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlLetteru45spacingFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Letteru45spacing] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Letteru45spacing] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Letteru45spacing((node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Letteru45spacing, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlJustifyFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Justify] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Justify] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Justify((node \ "@justify").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Justify, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlHalignFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Halign] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Halign] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Halign((node \ "@halign").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Halign, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlFontFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Font] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Font] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Font((node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Font, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
    __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
    __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
    __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlEnclosureFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Enclosure] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Enclosure] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Enclosure((node \ "@enclosure").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Enclosure, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlDocumentu45attributesFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Documentu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Documentu45attributes] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Documentu45attributes((node \ "@version").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Documentu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
      attr
    }
  }

  trait DefaultMusicxmlDirectiveTypeFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.DirectiveType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.DirectiveType] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.DirectiveType((node \ "@directive").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.DirectiveType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.directive foreach { x => attr = scala.xml.Attribute(null, "directive", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlDashedu45formattingFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Dashedu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Dashedu45formatting] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Dashedu45formatting((node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Dashedu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.toString, attr) }
    __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlColorFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Color] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Color] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Color((node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Color, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlBezierFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Bezier] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bezier] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bezier((node \ "@bezier-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-x2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-y2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-offset").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-offset2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Bezier, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.toString, attr) }
    __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.toString, attr) }
    __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.toString, attr) }
    __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.toString, attr) }
    __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.toString, attr) }
    __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxmlBendu45soundFormat extends scalaxb.AttributeGroupFormat[com.fdilke.musicxml.Bendu45sound] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.fdilke.musicxml.Bendu45sound] = seq match {
      case node: scala.xml.Node => Right(com.fdilke.musicxml.Bendu45sound((node \ "@accelerate").headOption map { scalaxb.fromXML[com.fdilke.musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@first-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.fdilke.musicxml.Bendu45sound, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
    __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.toString, attr) }
    __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.toString, attr) }
    __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.toString, attr) }
      attr
    }
  }


}

